/* automatically generated by rust-bindgen 0.69.5 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[derive(PartialEq, Copy, Clone, Hash, Debug, Default)]
#[repr(transparent)]
pub struct __BindgenFloat16(pub u16);
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC23: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 40;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _ASSERT_H: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const __alignas_is_defined: u32 = 1;
pub const __alignof_is_defined: u32 = 1;
pub const RTE_ARCH_X86: u32 = 1;
pub const RTE_ARCH_X86_64: u32 = 1;
pub const RTE_BASEBAND_ACC: u32 = 1;
pub const RTE_BASEBAND_FPGA_5GNR_FEC: u32 = 1;
pub const RTE_BASEBAND_FPGA_LTE_FEC: u32 = 1;
pub const RTE_BASEBAND_LA12XX: u32 = 1;
pub const RTE_BASEBAND_NULL: u32 = 1;
pub const RTE_BASEBAND_TURBO_SW: u32 = 1;
pub const RTE_BUS_AUXILIARY: u32 = 1;
pub const RTE_BUS_CDX: u32 = 1;
pub const RTE_BUS_DPAA: u32 = 1;
pub const RTE_BUS_FSLMC: u32 = 1;
pub const RTE_BUS_IFPGA: u32 = 1;
pub const RTE_BUS_PCI: u32 = 1;
pub const RTE_BUS_PLATFORM: u32 = 1;
pub const RTE_BUS_UACCE: u32 = 1;
pub const RTE_BUS_VDEV: u32 = 1;
pub const RTE_BUS_VMBUS: u32 = 1;
pub const RTE_CACHE_LINE_SIZE: u32 = 64;
pub const RTE_COMMON_CNXK: u32 = 1;
pub const RTE_COMMON_CPT: u32 = 1;
pub const RTE_COMMON_DPAAX: u32 = 1;
pub const RTE_COMMON_IAVF: u32 = 1;
pub const RTE_COMMON_IDPF: u32 = 1;
pub const RTE_COMMON_IONIC: u32 = 1;
pub const RTE_COMMON_MLX5: u32 = 1;
pub const RTE_COMMON_NFP: u32 = 1;
pub const RTE_COMMON_NITROX: u32 = 1;
pub const RTE_COMMON_OCTEONTX: u32 = 1;
pub const RTE_COMMON_QAT: u32 = 1;
pub const RTE_COMMON_SFC_EFX: u32 = 1;
pub const RTE_COMPRESS_MLX5: u32 = 1;
pub const RTE_COMPRESS_NITROX: u32 = 1;
pub const RTE_COMPRESS_OCTEONTX: u32 = 1;
pub const RTE_COMPRESS_ZLIB: u32 = 1;
pub const RTE_CRYPTO_BCMFS: u32 = 1;
pub const RTE_CRYPTO_CAAM_JR: u32 = 1;
pub const RTE_CRYPTO_CCP: u32 = 1;
pub const RTE_CRYPTO_CNXK: u32 = 1;
pub const RTE_CRYPTO_DPAA2_SEC: u32 = 1;
pub const RTE_CRYPTO_DPAA_SEC: u32 = 1;
pub const RTE_CRYPTO_IONIC: u32 = 1;
pub const RTE_CRYPTO_MLX5: u32 = 1;
pub const RTE_CRYPTO_NITROX: u32 = 1;
pub const RTE_CRYPTO_NULL: u32 = 1;
pub const RTE_CRYPTO_OCTEONTX: u32 = 1;
pub const RTE_CRYPTO_OPENSSL: u32 = 1;
pub const RTE_CRYPTO_SCHEDULER: u32 = 1;
pub const RTE_CRYPTO_VIRTIO: u32 = 1;
pub const RTE_DMA_CNXK: u32 = 1;
pub const RTE_DMA_DPAA: u32 = 1;
pub const RTE_DMA_DPAA2: u32 = 1;
pub const RTE_DMA_HISILICON: u32 = 1;
pub const RTE_DMA_IDXD: u32 = 1;
pub const RTE_DMA_IOAT: u32 = 1;
pub const RTE_DMA_ODM: u32 = 1;
pub const RTE_DMA_SKELETON: u32 = 1;
pub const RTE_DRIVER_MEMPOOL_BUCKET_SIZE_KB: u32 = 64;
pub const RTE_EAL_NUMA_AWARE_HUGEPAGES: u32 = 1;
pub const RTE_EAL_PMD_PATH: &[u8; 32] = b"/usr/local/lib64/dpdk/pmds-25.0\0";
pub const RTE_ENV_FREEBSD: u32 = 0;
pub const RTE_ENV_LINUX: u32 = 1;
pub const RTE_ENV_WINDOWS: u32 = 2;
pub const RTE_EVENT_CNXK: u32 = 1;
pub const RTE_EVENT_DLB2: u32 = 1;
pub const RTE_EVENT_DPAA: u32 = 1;
pub const RTE_EVENT_DPAA2: u32 = 1;
pub const RTE_EVENT_DSW: u32 = 1;
pub const RTE_EVENT_OCTEONTX: u32 = 1;
pub const RTE_EVENT_OPDL: u32 = 1;
pub const RTE_EVENT_SKELETON: u32 = 1;
pub const RTE_EVENT_SW: u32 = 1;
pub const RTE_EXEC_ENV: u32 = 1;
pub const RTE_EXEC_ENV_IS_FREEBSD: u32 = 0;
pub const RTE_EXEC_ENV_IS_LINUX: u32 = 1;
pub const RTE_EXEC_ENV_IS_WINDOWS: u32 = 0;
pub const RTE_EXEC_ENV_LINUX: u32 = 1;
pub const RTE_HAS_LIBNUMA: u32 = 1;
pub const RTE_HAS_LIBPCAP: u32 = 1;
pub const RTE_HAS_OPENSSL: u32 = 1;
pub const RTE_IOVA_IN_MBUF: u32 = 1;
pub const RTE_LIBRTE_BPF_ELF: u32 = 1;
pub const RTE_LIBRTE_VHOST_NUMA: u32 = 1;
pub const RTE_LIB_ACL: u32 = 1;
pub const RTE_LIB_ARGPARSE: u32 = 1;
pub const RTE_LIB_BBDEV: u32 = 1;
pub const RTE_LIB_BITRATESTATS: u32 = 1;
pub const RTE_LIB_BPF: u32 = 1;
pub const RTE_LIB_CFGFILE: u32 = 1;
pub const RTE_LIB_CMDLINE: u32 = 1;
pub const RTE_LIB_COMPRESSDEV: u32 = 1;
pub const RTE_LIB_CRYPTODEV: u32 = 1;
pub const RTE_LIB_DISPATCHER: u32 = 1;
pub const RTE_LIB_DISTRIBUTOR: u32 = 1;
pub const RTE_LIB_DMADEV: u32 = 1;
pub const RTE_LIB_EAL: u32 = 1;
pub const RTE_LIB_EFD: u32 = 1;
pub const RTE_LIB_ETHDEV: u32 = 1;
pub const RTE_LIB_EVENTDEV: u32 = 1;
pub const RTE_LIB_FIB: u32 = 1;
pub const RTE_LIB_GPUDEV: u32 = 1;
pub const RTE_LIB_GRAPH: u32 = 1;
pub const RTE_LIB_GRO: u32 = 1;
pub const RTE_LIB_GSO: u32 = 1;
pub const RTE_LIB_HASH: u32 = 1;
pub const RTE_LIB_IPSEC: u32 = 1;
pub const RTE_LIB_IP_FRAG: u32 = 1;
pub const RTE_LIB_JOBSTATS: u32 = 1;
pub const RTE_LIB_KVARGS: u32 = 1;
pub const RTE_LIB_LATENCYSTATS: u32 = 1;
pub const RTE_LIB_LOG: u32 = 1;
pub const RTE_LIB_LPM: u32 = 1;
pub const RTE_LIB_MBUF: u32 = 1;
pub const RTE_LIB_MEMBER: u32 = 1;
pub const RTE_LIB_MEMPOOL: u32 = 1;
pub const RTE_LIB_METER: u32 = 1;
pub const RTE_LIB_METRICS: u32 = 1;
pub const RTE_LIB_MLDEV: u32 = 1;
pub const RTE_LIB_NET: u32 = 1;
pub const RTE_LIB_NODE: u32 = 1;
pub const RTE_LIB_PCAPNG: u32 = 1;
pub const RTE_LIB_PCI: u32 = 1;
pub const RTE_LIB_PDCP: u32 = 1;
pub const RTE_LIB_PDUMP: u32 = 1;
pub const RTE_LIB_PIPELINE: u32 = 1;
pub const RTE_LIB_PORT: u32 = 1;
pub const RTE_LIB_POWER: u32 = 1;
pub const RTE_LIB_PTR_COMPRESS: u32 = 1;
pub const RTE_LIB_RAWDEV: u32 = 1;
pub const RTE_LIB_RCU: u32 = 1;
pub const RTE_LIB_REGEXDEV: u32 = 1;
pub const RTE_LIB_REORDER: u32 = 1;
pub const RTE_LIB_RIB: u32 = 1;
pub const RTE_LIB_RING: u32 = 1;
pub const RTE_LIB_SCHED: u32 = 1;
pub const RTE_LIB_SECURITY: u32 = 1;
pub const RTE_LIB_STACK: u32 = 1;
pub const RTE_LIB_TABLE: u32 = 1;
pub const RTE_LIB_TELEMETRY: u32 = 1;
pub const RTE_LIB_TIMER: u32 = 1;
pub const RTE_LIB_VHOST: u32 = 1;
pub const RTE_MAX_ETHPORTS: u32 = 32;
pub const RTE_MAX_LCORE: u32 = 128;
pub const RTE_MAX_MEM_MB: u32 = 524288;
pub const RTE_MAX_NUMA_NODES: u32 = 32;
pub const RTE_MAX_VFIO_GROUPS: u32 = 64;
pub const RTE_MEMPOOL_BUCKET: u32 = 1;
pub const RTE_MEMPOOL_CNXK: u32 = 1;
pub const RTE_MEMPOOL_DPAA: u32 = 1;
pub const RTE_MEMPOOL_DPAA2: u32 = 1;
pub const RTE_MEMPOOL_OCTEONTX: u32 = 1;
pub const RTE_MEMPOOL_RING: u32 = 1;
pub const RTE_MEMPOOL_STACK: u32 = 1;
pub const RTE_ML_CNXK: u32 = 1;
pub const RTE_NET_AF_PACKET: u32 = 1;
pub const RTE_NET_AF_XDP: u32 = 1;
pub const RTE_NET_ARK: u32 = 1;
pub const RTE_NET_ATLANTIC: u32 = 1;
pub const RTE_NET_AVP: u32 = 1;
pub const RTE_NET_AXGBE: u32 = 1;
pub const RTE_NET_BNX2X: u32 = 1;
pub const RTE_NET_BNXT: u32 = 1;
pub const RTE_NET_BOND: u32 = 1;
pub const RTE_NET_CNXK: u32 = 1;
pub const RTE_NET_CPFL: u32 = 1;
pub const RTE_NET_CXGBE: u32 = 1;
pub const RTE_NET_DPAA: u32 = 1;
pub const RTE_NET_DPAA2: u32 = 1;
pub const RTE_NET_E1000: u32 = 1;
pub const RTE_NET_ENA: u32 = 1;
pub const RTE_NET_ENETC: u32 = 1;
pub const RTE_NET_ENETFEC: u32 = 1;
pub const RTE_NET_ENIC: u32 = 1;
pub const RTE_NET_FAILSAFE: u32 = 1;
pub const RTE_NET_FM10K: u32 = 1;
pub const RTE_NET_GVE: u32 = 1;
pub const RTE_NET_HINIC: u32 = 1;
pub const RTE_NET_HNS3: u32 = 1;
pub const RTE_NET_I40E: u32 = 1;
pub const RTE_NET_IAVF: u32 = 1;
pub const RTE_NET_ICE: u32 = 1;
pub const RTE_NET_IDPF: u32 = 1;
pub const RTE_NET_IGC: u32 = 1;
pub const RTE_NET_IONIC: u32 = 1;
pub const RTE_NET_IXGBE: u32 = 1;
pub const RTE_NET_MANA: u32 = 1;
pub const RTE_NET_MEMIF: u32 = 1;
pub const RTE_NET_MLX4: u32 = 1;
pub const RTE_NET_MLX5: u32 = 1;
pub const RTE_NET_NETVSC: u32 = 1;
pub const RTE_NET_NFP: u32 = 1;
pub const RTE_NET_NGBE: u32 = 1;
pub const RTE_NET_NTNIC: u32 = 1;
pub const RTE_NET_NULL: u32 = 1;
pub const RTE_NET_OCTEONTX: u32 = 1;
pub const RTE_NET_OCTEON_EP: u32 = 1;
pub const RTE_NET_PCAP: u32 = 1;
pub const RTE_NET_PFE: u32 = 1;
pub const RTE_NET_QEDE: u32 = 1;
pub const RTE_NET_R8169: u32 = 1;
pub const RTE_NET_RING: u32 = 1;
pub const RTE_NET_SFC: u32 = 1;
pub const RTE_NET_SOFTNIC: u32 = 1;
pub const RTE_NET_TAP: u32 = 1;
pub const RTE_NET_THUNDERX: u32 = 1;
pub const RTE_NET_TXGBE: u32 = 1;
pub const RTE_NET_VDEV_NETVSC: u32 = 1;
pub const RTE_NET_VHOST: u32 = 1;
pub const RTE_NET_VIRTIO: u32 = 1;
pub const RTE_NET_VMXNET3: u32 = 1;
pub const RTE_NET_ZXDH: u32 = 1;
pub const RTE_PKTMBUF_HEADROOM: u32 = 128;
pub const RTE_PORT_PCAP: u32 = 1;
pub const RTE_POWER_ACPI: u32 = 1;
pub const RTE_POWER_AMD_PSTATE: u32 = 1;
pub const RTE_POWER_CPPC: u32 = 1;
pub const RTE_POWER_INTEL_PSTATE: u32 = 1;
pub const RTE_POWER_INTEL_UNCORE: u32 = 1;
pub const RTE_POWER_KVM_VM: u32 = 1;
pub const RTE_RAW_CNXK_BPHY: u32 = 1;
pub const RTE_RAW_CNXK_GPIO: u32 = 1;
pub const RTE_RAW_CNXK_RVU_LF: u32 = 1;
pub const RTE_RAW_DPAA2_CMDIF: u32 = 1;
pub const RTE_RAW_GDTC: u32 = 1;
pub const RTE_RAW_NTB: u32 = 1;
pub const RTE_RAW_SKELETON: u32 = 1;
pub const RTE_REGEX_CN9K: u32 = 1;
pub const RTE_REGEX_MLX5: u32 = 1;
pub const RTE_VDPA_IFC: u32 = 1;
pub const RTE_VDPA_MLX5: u32 = 1;
pub const RTE_VDPA_NFP: u32 = 1;
pub const RTE_VDPA_SFC: u32 = 1;
pub const RTE_VER_MINOR: u32 = 1;
pub const RTE_VER_MONTH: u32 = 11;
pub const RTE_VER_RELEASE: u32 = 99;
pub const RTE_VER_SUFFIX: &[u8; 1] = b"\0";
pub const RTE_VER_YEAR: u32 = 24;
pub const RTE_TOOLCHAIN: &[u8; 6] = b"clang\0";
pub const RTE_TOOLCHAIN_CLANG: u32 = 1;
pub const RTE_EXEC_ENV_LINUXAPP: u32 = 1;
pub const RTE_VER_PREFIX: &[u8; 5] = b"DPDK\0";
pub const RTE_CACHE_GUARD_LINES: u32 = 1;
pub const RTE_MAX_HEAPS: u32 = 32;
pub const RTE_MAX_LCORE_VAR: u32 = 131072;
pub const RTE_MAX_MEMSEG_LISTS: u32 = 128;
pub const RTE_MAX_MEMSEG_PER_LIST: u32 = 8192;
pub const RTE_MAX_MEM_MB_PER_LIST: u32 = 32768;
pub const RTE_MAX_MEMSEG_PER_TYPE: u32 = 32768;
pub const RTE_MAX_MEM_MB_PER_TYPE: u32 = 65536;
pub const RTE_MAX_TAILQ: u32 = 32;
pub const RTE_MAX_VFIO_CONTAINERS: u32 = 64;
pub const RTE_TRACE: u32 = 1;
pub const RTE_CONTIGMEM_MAX_NUM_BUFS: u32 = 64;
pub const RTE_CONTIGMEM_DEFAULT_NUM_BUFS: u32 = 1;
pub const RTE_CONTIGMEM_DEFAULT_BUF_SIZE: u32 = 536870912;
pub const RTE_MEMPOOL_CACHE_MAX_SIZE: u32 = 512;
pub const RTE_MBUF_DEFAULT_MEMPOOL_OPS: &[u8; 11] = b"ring_mp_mc\0";
pub const RTE_MAX_QUEUES_PER_PORT: u32 = 1024;
pub const RTE_ETHDEV_QUEUE_STAT_CNTRS: u32 = 16;
pub const RTE_ETHDEV_RXTX_CALLBACKS: u32 = 1;
pub const RTE_MAX_MULTI_HOST_CTRLS: u32 = 4;
pub const RTE_CRYPTO_MAX_DEVS: u32 = 64;
pub const RTE_CRYPTODEV_NAME_LEN: u32 = 64;
pub const RTE_CRYPTO_CALLBACKS: u32 = 1;
pub const RTE_COMPRESS_MAX_DEVS: u32 = 64;
pub const RTE_MAX_REGEXDEV_DEVS: u32 = 32;
pub const RTE_EVENT_MAX_DEVS: u32 = 16;
pub const RTE_EVENT_MAX_PORTS_PER_DEV: u32 = 255;
pub const RTE_EVENT_MAX_QUEUES_PER_DEV: u32 = 255;
pub const RTE_EVENT_MAX_PROFILES_PER_PORT: u32 = 8;
pub const RTE_EVENT_TIMER_ADAPTER_NUM_MAX: u32 = 32;
pub const RTE_EVENT_ETH_INTR_RING_SIZE: u32 = 1024;
pub const RTE_EVENT_CRYPTO_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_EVENT_ETH_TX_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_EVENT_DMA_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_RAWDEV_MAX_DEVS: u32 = 64;
pub const RTE_LIBRTE_IP_FRAG_MAX_FRAG: u32 = 8;
pub const RTE_MAX_LCORE_FREQS: u32 = 64;
pub const RTE_MAX_UNCORE_FREQS: u32 = 64;
pub const RTE_GRAPH_BURST_SIZE: u32 = 256;
pub const RTE_LIBRTE_GRAPH_STATS: u32 = 1;
pub const RTE_PMD_PACKET_PREFETCH: u32 = 1;
pub const RTE_PMD_QAT_MAX_PCI_DEVICES: u32 = 48;
pub const RTE_PMD_QAT_COMP_SGL_MAX_SEGMENTS: u32 = 16;
pub const RTE_PMD_QAT_COMP_IM_BUFFER_SIZE: u32 = 65536;
pub const RTE_MAX_VIRTIO_CRYPTO: u32 = 32;
pub const RTE_LIBRTE_DPAA_MAX_CRYPTODEV: u32 = 4;
pub const RTE_LIBRTE_FM10K_RX_OLFLAGS_ENABLE: u32 = 1;
pub const RTE_LIBRTE_HNS3_MAX_TQP_NUM_PER_PF: u32 = 256;
pub const RTE_LIBRTE_I40E_RX_ALLOW_BULK_ALLOC: u32 = 1;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_PF: u32 = 64;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_VF: u32 = 4;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_VM: u32 = 4;
pub const RTE_PMD_RING_MAX_RX_RINGS: u32 = 16;
pub const RTE_PMD_RING_MAX_TX_RINGS: u32 = 16;
pub const RTE_LIBRTE_QEDE_FW: &[u8; 1] = b"\0";
pub const _SCHED_H: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const RTE_CC_IS_GNU: u32 = 0;
pub const RTE_PRIORITY_LOG: u32 = 101;
pub const RTE_PRIORITY_BUS: u32 = 110;
pub const RTE_PRIORITY_CLASS: u32 = 120;
pub const RTE_PRIORITY_LAST: u32 = 65535;
pub const RTE_CACHE_LINE_MASK: u32 = 63;
pub const RTE_CACHE_LINE_SIZE_LOG2: u32 = 6;
pub const RTE_CACHE_LINE_MIN_SIZE: u32 = 64;
pub const _ENDIAN_H: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const RTE_BIG_ENDIAN: u32 = 1;
pub const RTE_LITTLE_ENDIAN: u32 = 2;
pub const RTE_BYTE_ORDER: u32 = 2;
pub const RTE_L2TPV2_MSG_TYPE_CONTROL: u32 = 51202;
pub const RTE_L2TPV2_MSG_TYPE_DATA: u32 = 2;
pub const RTE_L2TPV2_MSG_TYPE_DATA_L: u32 = 16386;
pub const RTE_L2TPV2_MSG_TYPE_DATA_S: u32 = 2050;
pub const RTE_L2TPV2_MSG_TYPE_DATA_O: u32 = 514;
pub const RTE_L2TPV2_MSG_TYPE_DATA_L_S: u32 = 18434;
pub const RTE_L2TPV2_MSG_TYPE_DATA_L_O: u32 = 16898;
pub const RTE_L2TPV2_MSG_TYPE_DATA_S_O: u32 = 2562;
pub const RTE_L2TPV2_MSG_TYPE_DATA_L_S_O: u32 = 18946;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const __ILP32_OFF32_CFLAGS: &[u8; 5] = b"-m32\0";
pub const __ILP32_OFF32_LDFLAGS: &[u8; 5] = b"-m32\0";
pub const __ILP32_OFFBIG_CFLAGS: &[u8; 48] = b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const __ILP32_OFFBIG_LDFLAGS: &[u8; 5] = b"-m32\0";
pub const __LP64_OFF64_CFLAGS: &[u8; 5] = b"-m64\0";
pub const __LP64_OFF64_LDFLAGS: &[u8; 5] = b"-m64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const RTE_UUID_STRLEN: u32 = 37;
pub const RTE_MAGIC: u32 = 19820526;
pub const RTE_MP_MAX_FD_NUM: u32 = 253;
pub const RTE_MP_MAX_NAME_LEN: u32 = 64;
pub const RTE_MP_MAX_PARAM_LEN: u32 = 256;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 3] = b"ld\0";
pub const PRIdFAST32: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 3] = b"li\0";
pub const PRIiFAST32: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 3] = b"lo\0";
pub const PRIoFAST32: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 3] = b"lu\0";
pub const PRIuFAST32: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 3] = b"lx\0";
pub const PRIxFAST32: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 3] = b"lX\0";
pub const PRIXFAST32: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3] = b"ld\0";
pub const SCNdFAST32: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3] = b"li\0";
pub const SCNiFAST32: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3] = b"lu\0";
pub const SCNuFAST32: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 3] = b"lo\0";
pub const SCNoFAST32: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3] = b"lx\0";
pub const SCNxFAST32: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const RTE_THREAD_NAME_SIZE: u32 = 16;
pub const RTE_MAX_THREAD_NAME_LEN: u32 = 16;
pub const RTE_THREAD_INTERNAL_PREFIX: &[u8; 6] = b"dpdk-\0";
pub const RTE_THREAD_INTERNAL_NAME_SIZE: u32 = 11;
pub const LCORE_ID_ANY: u32 = 4294967295;
pub const _MM_HINT_ET0: u32 = 7;
pub const _MM_HINT_ET1: u32 = 6;
pub const _MM_HINT_T0: u32 = 3;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 1;
pub const _MM_HINT_NTA: u32 = 0;
pub const _CMP_EQ_OQ: u32 = 0;
pub const _CMP_LT_OS: u32 = 1;
pub const _CMP_LE_OS: u32 = 2;
pub const _CMP_UNORD_Q: u32 = 3;
pub const _CMP_NEQ_UQ: u32 = 4;
pub const _CMP_NLT_US: u32 = 5;
pub const _CMP_NLE_US: u32 = 6;
pub const _CMP_ORD_Q: u32 = 7;
pub const _MM_EXCEPT_INVALID: u32 = 1;
pub const _MM_EXCEPT_DENORM: u32 = 2;
pub const _MM_EXCEPT_DIV_ZERO: u32 = 4;
pub const _MM_EXCEPT_OVERFLOW: u32 = 8;
pub const _MM_EXCEPT_UNDERFLOW: u32 = 16;
pub const _MM_EXCEPT_INEXACT: u32 = 32;
pub const _MM_EXCEPT_MASK: u32 = 63;
pub const _MM_MASK_INVALID: u32 = 128;
pub const _MM_MASK_DENORM: u32 = 256;
pub const _MM_MASK_DIV_ZERO: u32 = 512;
pub const _MM_MASK_OVERFLOW: u32 = 1024;
pub const _MM_MASK_UNDERFLOW: u32 = 2048;
pub const _MM_MASK_INEXACT: u32 = 4096;
pub const _MM_MASK_MASK: u32 = 8064;
pub const _MM_ROUND_NEAREST: u32 = 0;
pub const _MM_ROUND_DOWN: u32 = 8192;
pub const _MM_ROUND_UP: u32 = 16384;
pub const _MM_ROUND_TOWARD_ZERO: u32 = 24576;
pub const _MM_ROUND_MASK: u32 = 24576;
pub const _MM_FLUSH_ZERO_MASK: u32 = 32768;
pub const _MM_FLUSH_ZERO_ON: u32 = 32768;
pub const _MM_FLUSH_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_ON: u32 = 64;
pub const _MM_DENORMALS_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_MASK: u32 = 64;
pub const MPLOCKED: &[u8; 8] = b"lock ; \0";
pub const _RTE_RTM_H_: u32 = 1;
pub const __SAVE_GPRBX: &[u8; 30] = b"mov {%%rbx, %%rax |rax, rbx};\0";
pub const __RESTORE_GPRBX: &[u8; 30] = b"mov {%%rax, %%rbx |rbx, rax};\0";
pub const __TMPGPR: &[u8; 4] = b"rax\0";
pub const _MM_FROUND_TO_NEAREST_INT: u32 = 0;
pub const _MM_FROUND_TO_NEG_INF: u32 = 1;
pub const _MM_FROUND_TO_POS_INF: u32 = 2;
pub const _MM_FROUND_TO_ZERO: u32 = 3;
pub const _MM_FROUND_CUR_DIRECTION: u32 = 4;
pub const _MM_FROUND_RAISE_EXC: u32 = 0;
pub const _MM_FROUND_NO_EXC: u32 = 8;
pub const _MM_FROUND_NINT: u32 = 0;
pub const _MM_FROUND_FLOOR: u32 = 1;
pub const _MM_FROUND_CEIL: u32 = 2;
pub const _MM_FROUND_TRUNC: u32 = 3;
pub const _MM_FROUND_RINT: u32 = 4;
pub const _MM_FROUND_NEARBYINT: u32 = 12;
pub const _SIDD_UBYTE_OPS: u32 = 0;
pub const _SIDD_UWORD_OPS: u32 = 1;
pub const _SIDD_SBYTE_OPS: u32 = 2;
pub const _SIDD_SWORD_OPS: u32 = 3;
pub const _SIDD_CMP_EQUAL_ANY: u32 = 0;
pub const _SIDD_CMP_RANGES: u32 = 4;
pub const _SIDD_CMP_EQUAL_EACH: u32 = 8;
pub const _SIDD_CMP_EQUAL_ORDERED: u32 = 12;
pub const _SIDD_POSITIVE_POLARITY: u32 = 0;
pub const _SIDD_NEGATIVE_POLARITY: u32 = 16;
pub const _SIDD_MASKED_POSITIVE_POLARITY: u32 = 32;
pub const _SIDD_MASKED_NEGATIVE_POLARITY: u32 = 48;
pub const _SIDD_LEAST_SIGNIFICANT: u32 = 0;
pub const _SIDD_MOST_SIGNIFICANT: u32 = 64;
pub const _SIDD_BIT_MASK: u32 = 0;
pub const _SIDD_UNIT_MASK: u32 = 64;
pub const _CMP_EQ_UQ: u32 = 8;
pub const _CMP_NGE_US: u32 = 9;
pub const _CMP_NGT_US: u32 = 10;
pub const _CMP_FALSE_OQ: u32 = 11;
pub const _CMP_NEQ_OQ: u32 = 12;
pub const _CMP_GE_OS: u32 = 13;
pub const _CMP_GT_OS: u32 = 14;
pub const _CMP_TRUE_UQ: u32 = 15;
pub const _CMP_EQ_OS: u32 = 16;
pub const _CMP_LT_OQ: u32 = 17;
pub const _CMP_LE_OQ: u32 = 18;
pub const _CMP_UNORD_S: u32 = 19;
pub const _CMP_NEQ_US: u32 = 20;
pub const _CMP_NLT_UQ: u32 = 21;
pub const _CMP_NLE_UQ: u32 = 22;
pub const _CMP_ORD_S: u32 = 23;
pub const _CMP_EQ_US: u32 = 24;
pub const _CMP_NGE_UQ: u32 = 25;
pub const _CMP_NGT_UQ: u32 = 26;
pub const _CMP_FALSE_OS: u32 = 27;
pub const _CMP_NEQ_OS: u32 = 28;
pub const _CMP_GE_OQ: u32 = 29;
pub const _CMP_GT_OQ: u32 = 30;
pub const _CMP_TRUE_US: u32 = 31;
pub const _XBEGIN_STARTED: i32 = -1;
pub const _XABORT_EXPLICIT: u32 = 1;
pub const _XABORT_RETRY: u32 = 2;
pub const _XABORT_CONFLICT: u32 = 4;
pub const _XABORT_CAPACITY: u32 = 8;
pub const _XABORT_DEBUG: u32 = 16;
pub const _XABORT_NESTED: u32 = 32;
pub const __PCONFIG_KEY_PROGRAM: u32 = 1;
pub const RTE_XBEGIN_STARTED: i32 = -1;
pub const RTE_XABORT_EXPLICIT: u32 = 1;
pub const RTE_XABORT_RETRY: u32 = 2;
pub const RTE_XABORT_CONFLICT: u32 = 4;
pub const RTE_XABORT_CAPACITY: u32 = 8;
pub const RTE_XABORT_DEBUG: u32 = 16;
pub const RTE_XABORT_NESTED: u32 = 32;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const _MM_PCOMCTRL_LT: u32 = 0;
pub const _MM_PCOMCTRL_LE: u32 = 1;
pub const _MM_PCOMCTRL_GT: u32 = 2;
pub const _MM_PCOMCTRL_GE: u32 = 3;
pub const _MM_PCOMCTRL_EQ: u32 = 4;
pub const _MM_PCOMCTRL_NEQ: u32 = 5;
pub const _MM_PCOMCTRL_FALSE: u32 = 6;
pub const _MM_PCOMCTRL_TRUE: u32 = 7;
pub const __RDPRU_MPERF: u32 = 0;
pub const __RDPRU_APERF: u32 = 1;
pub const RTE_LOGTYPE_EAL: u32 = 0;
pub const RTE_LOGTYPE_USER1: u32 = 24;
pub const RTE_LOGTYPE_USER2: u32 = 25;
pub const RTE_LOGTYPE_USER3: u32 = 26;
pub const RTE_LOGTYPE_USER4: u32 = 27;
pub const RTE_LOGTYPE_USER5: u32 = 28;
pub const RTE_LOGTYPE_USER6: u32 = 29;
pub const RTE_LOGTYPE_USER7: u32 = 30;
pub const RTE_LOGTYPE_USER8: u32 = 31;
pub const RTE_LOGTYPE_FIRST_EXT_ID: u32 = 32;
pub const RTE_LOG_EMERG: u32 = 1;
pub const RTE_LOG_ALERT: u32 = 2;
pub const RTE_LOG_CRIT: u32 = 3;
pub const RTE_LOG_ERR: u32 = 4;
pub const RTE_LOG_WARNING: u32 = 5;
pub const RTE_LOG_NOTICE: u32 = 6;
pub const RTE_LOG_INFO: u32 = 7;
pub const RTE_LOG_DEBUG: u32 = 8;
pub const RTE_LOG_MAX: u32 = 8;
pub const MS_PER_S: u32 = 1000;
pub const US_PER_S: u32 = 1000000;
pub const NS_PER_S: u32 = 1000000000;
pub const RTE_RTM_MAX_RETRIES: u32 = 20;
pub const RTE_XABORT_LOCK_BUSY: u32 = 255;
pub const RTE_RWLOCK_WAIT: u32 = 1;
pub const RTE_RWLOCK_WRITE: u32 = 2;
pub const RTE_RWLOCK_MASK: u32 = 3;
pub const RTE_RWLOCK_READ: u32 = 4;
pub const RTE_FBARRAY_NAME_LEN: u32 = 64;
pub const RTE_PGSIZE_4K: u32 = 4096;
pub const RTE_PGSIZE_64K: u32 = 65536;
pub const RTE_PGSIZE_256K: u32 = 262144;
pub const RTE_PGSIZE_2M: u32 = 2097152;
pub const RTE_PGSIZE_16M: u32 = 16777216;
pub const RTE_PGSIZE_256M: u32 = 268435456;
pub const RTE_PGSIZE_512M: u32 = 536870912;
pub const RTE_PGSIZE_1G: u32 = 1073741824;
pub const RTE_PGSIZE_4G: u64 = 4294967296;
pub const RTE_PGSIZE_16G: u64 = 17179869184;
pub const SOCKET_ID_ANY: i32 = -1;
pub const RTE_MEM_EVENT_CALLBACK_NAME_LEN: u32 = 64;
pub const RTE_MEM_ALLOC_VALIDATOR_NAME_LEN: u32 = 64;
pub const RTE_MEMZONE_2MB: u32 = 1;
pub const RTE_MEMZONE_1GB: u32 = 2;
pub const RTE_MEMZONE_16MB: u32 = 256;
pub const RTE_MEMZONE_16GB: u32 = 512;
pub const RTE_MEMZONE_256KB: u32 = 65536;
pub const RTE_MEMZONE_256MB: u32 = 131072;
pub const RTE_MEMZONE_512MB: u32 = 262144;
pub const RTE_MEMZONE_4GB: u32 = 524288;
pub const RTE_MEMZONE_SIZE_HINT_ONLY: u32 = 4;
pub const RTE_MEMZONE_IOVA_CONTIG: u32 = 1048576;
pub const RTE_MEMZONE_NAMESIZE: u32 = 32;
pub const RTE_TAILQ_RING_NAME: &[u8; 9] = b"RTE_RING\0";
pub const RTE_RING_MZ_PREFIX: &[u8; 4] = b"RG_\0";
pub const RING_F_SP_ENQ: u32 = 1;
pub const RING_F_SC_DEQ: u32 = 2;
pub const RING_F_EXACT_SZ: u32 = 4;
pub const RTE_RING_SZ_MASK: u32 = 2147483647;
pub const RING_F_MP_RTS_ENQ: u32 = 8;
pub const RING_F_MC_RTS_DEQ: u32 = 16;
pub const RING_F_MP_HTS_ENQ: u32 = 32;
pub const RING_F_MC_HTS_DEQ: u32 = 64;
pub const XMM_SIZE: u32 = 16;
pub const XMM_MASK: u32 = 15;
pub const ALIGNMENT_MASK: u32 = 15;
pub const _CTYPE_H: u32 = 1;
pub const __RTE_TRACE_EMIT_STRING_LEN_MAX: u32 = 32;
pub const RTE_TRACE_BLOB_LEN_MAX: u32 = 64;
pub const RTE_MEMPOOL_HEADER_COOKIE1: i64 = -4982197544707871147;
pub const RTE_MEMPOOL_HEADER_COOKIE2: i64 = -941548164385788331;
pub const RTE_MEMPOOL_TRAILER_COOKIE: i64 = -5921418378119291987;
pub const RTE_MEMPOOL_MZ_PREFIX: &[u8; 4] = b"MP_\0";
pub const RTE_MEMPOOL_MZ_FORMAT: &[u8; 6] = b"MP_%s\0";
pub const RTE_MEMPOOL_ALIGN: u32 = 64;
pub const RTE_MEMPOOL_ALIGN_MASK: u32 = 63;
pub const RTE_MEMPOOL_F_NO_SPREAD: u32 = 1;
pub const MEMPOOL_F_NO_SPREAD: u32 = 1;
pub const RTE_MEMPOOL_F_NO_CACHE_ALIGN: u32 = 2;
pub const MEMPOOL_F_NO_CACHE_ALIGN: u32 = 2;
pub const RTE_MEMPOOL_F_SP_PUT: u32 = 4;
pub const MEMPOOL_F_SP_PUT: u32 = 4;
pub const RTE_MEMPOOL_F_SC_GET: u32 = 8;
pub const MEMPOOL_F_SC_GET: u32 = 8;
pub const RTE_MEMPOOL_F_POOL_CREATED: u32 = 16;
pub const RTE_MEMPOOL_F_NO_IOVA_CONTIG: u32 = 32;
pub const MEMPOOL_F_NO_IOVA_CONTIG: u32 = 32;
pub const RTE_MEMPOOL_F_NON_IO: u32 = 64;
pub const RTE_MEMPOOL_VALID_USER_FLAGS: u32 = 47;
pub const RTE_MEMPOOL_OPS_NAMESIZE: u32 = 32;
pub const RTE_MEMPOOL_POPULATE_F_ALIGN_OBJ: u32 = 1;
pub const RTE_MEMPOOL_MAX_OPS_IDX: u32 = 16;
pub const RTE_PTYPE_UNKNOWN: u32 = 0;
pub const RTE_PTYPE_L2_ETHER: u32 = 1;
pub const RTE_PTYPE_L2_ETHER_TIMESYNC: u32 = 2;
pub const RTE_PTYPE_L2_ETHER_ARP: u32 = 3;
pub const RTE_PTYPE_L2_ETHER_LLDP: u32 = 4;
pub const RTE_PTYPE_L2_ETHER_NSH: u32 = 5;
pub const RTE_PTYPE_L2_ETHER_VLAN: u32 = 6;
pub const RTE_PTYPE_L2_ETHER_QINQ: u32 = 7;
pub const RTE_PTYPE_L2_ETHER_PPPOE: u32 = 8;
pub const RTE_PTYPE_L2_ETHER_FCOE: u32 = 9;
pub const RTE_PTYPE_L2_ETHER_MPLS: u32 = 10;
pub const RTE_PTYPE_L2_MASK: u32 = 15;
pub const RTE_PTYPE_L3_IPV4: u32 = 16;
pub const RTE_PTYPE_L3_IPV4_EXT: u32 = 48;
pub const RTE_PTYPE_L3_IPV6: u32 = 64;
pub const RTE_PTYPE_L3_IPV4_EXT_UNKNOWN: u32 = 144;
pub const RTE_PTYPE_L3_IPV6_EXT: u32 = 192;
pub const RTE_PTYPE_L3_IPV6_EXT_UNKNOWN: u32 = 224;
pub const RTE_PTYPE_L3_MASK: u32 = 240;
pub const RTE_PTYPE_L4_TCP: u32 = 256;
pub const RTE_PTYPE_L4_UDP: u32 = 512;
pub const RTE_PTYPE_L4_FRAG: u32 = 768;
pub const RTE_PTYPE_L4_SCTP: u32 = 1024;
pub const RTE_PTYPE_L4_ICMP: u32 = 1280;
pub const RTE_PTYPE_L4_NONFRAG: u32 = 1536;
pub const RTE_PTYPE_L4_IGMP: u32 = 1792;
pub const RTE_PTYPE_L4_ESP: u32 = 2048;
pub const RTE_PTYPE_L4_MASK: u32 = 3840;
pub const RTE_PTYPE_TUNNEL_IP: u32 = 4096;
pub const RTE_PTYPE_TUNNEL_GRE: u32 = 8192;
pub const RTE_PTYPE_TUNNEL_VXLAN: u32 = 12288;
pub const RTE_PTYPE_TUNNEL_NVGRE: u32 = 16384;
pub const RTE_PTYPE_TUNNEL_GENEVE: u32 = 20480;
pub const RTE_PTYPE_TUNNEL_GRENAT: u32 = 24576;
pub const RTE_PTYPE_TUNNEL_GTPC: u32 = 28672;
pub const RTE_PTYPE_TUNNEL_GTPU: u32 = 32768;
pub const RTE_PTYPE_TUNNEL_ESP: u32 = 36864;
pub const RTE_PTYPE_TUNNEL_L2TP: u32 = 40960;
pub const RTE_PTYPE_TUNNEL_VXLAN_GPE: u32 = 45056;
pub const RTE_PTYPE_TUNNEL_MPLS_IN_GRE: u32 = 49152;
pub const RTE_PTYPE_TUNNEL_MPLS_IN_UDP: u32 = 53248;
pub const RTE_PTYPE_TUNNEL_MASK: u32 = 61440;
pub const RTE_PTYPE_INNER_L2_ETHER: u32 = 65536;
pub const RTE_PTYPE_INNER_L2_ETHER_VLAN: u32 = 131072;
pub const RTE_PTYPE_INNER_L2_ETHER_QINQ: u32 = 196608;
pub const RTE_PTYPE_INNER_L2_MASK: u32 = 983040;
pub const RTE_PTYPE_INNER_L3_IPV4: u32 = 1048576;
pub const RTE_PTYPE_INNER_L3_IPV4_EXT: u32 = 2097152;
pub const RTE_PTYPE_INNER_L3_IPV6: u32 = 3145728;
pub const RTE_PTYPE_INNER_L3_IPV4_EXT_UNKNOWN: u32 = 4194304;
pub const RTE_PTYPE_INNER_L3_IPV6_EXT: u32 = 5242880;
pub const RTE_PTYPE_INNER_L3_IPV6_EXT_UNKNOWN: u32 = 6291456;
pub const RTE_PTYPE_INNER_L3_MASK: u32 = 15728640;
pub const RTE_PTYPE_INNER_L4_TCP: u32 = 16777216;
pub const RTE_PTYPE_INNER_L4_UDP: u32 = 33554432;
pub const RTE_PTYPE_INNER_L4_FRAG: u32 = 50331648;
pub const RTE_PTYPE_INNER_L4_SCTP: u32 = 67108864;
pub const RTE_PTYPE_INNER_L4_ICMP: u32 = 83886080;
pub const RTE_PTYPE_INNER_L4_NONFRAG: u32 = 100663296;
pub const RTE_PTYPE_INNER_L4_ESP: u32 = 134217728;
pub const RTE_PTYPE_INNER_L4_MASK: u32 = 251658240;
pub const RTE_PTYPE_ALL_MASK: u32 = 268435455;
pub const RTE_MBUF_F_RX_VLAN: u32 = 1;
pub const RTE_MBUF_F_RX_RSS_HASH: u32 = 2;
pub const RTE_MBUF_F_RX_FDIR: u32 = 4;
pub const RTE_MBUF_F_RX_OUTER_IP_CKSUM_BAD: u32 = 32;
pub const RTE_MBUF_F_RX_VLAN_STRIPPED: u32 = 64;
pub const RTE_MBUF_F_RX_IP_CKSUM_MASK: u32 = 144;
pub const RTE_MBUF_F_RX_IP_CKSUM_UNKNOWN: u32 = 0;
pub const RTE_MBUF_F_RX_IP_CKSUM_BAD: u32 = 16;
pub const RTE_MBUF_F_RX_IP_CKSUM_GOOD: u32 = 128;
pub const RTE_MBUF_F_RX_IP_CKSUM_NONE: u32 = 144;
pub const RTE_MBUF_F_RX_L4_CKSUM_MASK: u32 = 264;
pub const RTE_MBUF_F_RX_L4_CKSUM_UNKNOWN: u32 = 0;
pub const RTE_MBUF_F_RX_L4_CKSUM_BAD: u32 = 8;
pub const RTE_MBUF_F_RX_L4_CKSUM_GOOD: u32 = 256;
pub const RTE_MBUF_F_RX_L4_CKSUM_NONE: u32 = 264;
pub const RTE_MBUF_F_RX_IEEE1588_PTP: u32 = 512;
pub const RTE_MBUF_F_RX_IEEE1588_TMST: u32 = 1024;
pub const RTE_MBUF_F_RX_FDIR_ID: u32 = 8192;
pub const RTE_MBUF_F_RX_FDIR_FLX: u32 = 16384;
pub const RTE_MBUF_F_RX_QINQ_STRIPPED: u32 = 32768;
pub const RTE_MBUF_F_RX_LRO: u32 = 65536;
pub const RTE_MBUF_F_RX_SEC_OFFLOAD: u32 = 262144;
pub const RTE_MBUF_F_RX_SEC_OFFLOAD_FAILED: u32 = 524288;
pub const RTE_MBUF_F_RX_QINQ: u32 = 1048576;
pub const RTE_MBUF_F_RX_OUTER_L4_CKSUM_MASK: u32 = 6291456;
pub const RTE_MBUF_F_RX_OUTER_L4_CKSUM_UNKNOWN: u32 = 0;
pub const RTE_MBUF_F_RX_OUTER_L4_CKSUM_BAD: u32 = 2097152;
pub const RTE_MBUF_F_RX_OUTER_L4_CKSUM_GOOD: u32 = 4194304;
pub const RTE_MBUF_F_RX_OUTER_L4_CKSUM_INVALID: u32 = 6291456;
pub const RTE_MBUF_F_FIRST_FREE: u32 = 8388608;
pub const RTE_MBUF_F_LAST_FREE: u64 = 1099511627776;
pub const RTE_MBUF_F_TX_OUTER_UDP_CKSUM: u64 = 2199023255552;
pub const RTE_MBUF_F_TX_UDP_SEG: u64 = 4398046511104;
pub const RTE_MBUF_F_TX_SEC_OFFLOAD: u64 = 8796093022208;
pub const RTE_MBUF_F_TX_MACSEC: u64 = 17592186044416;
pub const RTE_MBUF_F_TX_TUNNEL_VXLAN: u64 = 35184372088832;
pub const RTE_MBUF_F_TX_TUNNEL_GRE: u64 = 70368744177664;
pub const RTE_MBUF_F_TX_TUNNEL_IPIP: u64 = 105553116266496;
pub const RTE_MBUF_F_TX_TUNNEL_GENEVE: u64 = 140737488355328;
pub const RTE_MBUF_F_TX_TUNNEL_MPLSINUDP: u64 = 175921860444160;
pub const RTE_MBUF_F_TX_TUNNEL_VXLAN_GPE: u64 = 211106232532992;
pub const RTE_MBUF_F_TX_TUNNEL_GTP: u64 = 246290604621824;
pub const RTE_MBUF_F_TX_TUNNEL_ESP: u64 = 281474976710656;
pub const RTE_MBUF_F_TX_TUNNEL_IP: u64 = 457396837154816;
pub const RTE_MBUF_F_TX_TUNNEL_UDP: u64 = 492581209243648;
pub const RTE_MBUF_F_TX_TUNNEL_MASK: u64 = 527765581332480;
pub const RTE_MBUF_F_TX_QINQ: u64 = 562949953421312;
pub const RTE_MBUF_F_TX_TCP_SEG: u64 = 1125899906842624;
pub const RTE_MBUF_F_TX_IEEE1588_TMST: u64 = 2251799813685248;
pub const RTE_MBUF_F_TX_L4_NO_CKSUM: u32 = 0;
pub const RTE_MBUF_F_TX_TCP_CKSUM: u64 = 4503599627370496;
pub const RTE_MBUF_F_TX_SCTP_CKSUM: u64 = 9007199254740992;
pub const RTE_MBUF_F_TX_UDP_CKSUM: u64 = 13510798882111488;
pub const RTE_MBUF_F_TX_L4_MASK: u64 = 13510798882111488;
pub const RTE_MBUF_F_TX_IP_CKSUM: u64 = 18014398509481984;
pub const RTE_MBUF_F_TX_IPV4: u64 = 36028797018963968;
pub const RTE_MBUF_F_TX_IPV6: u64 = 72057594037927936;
pub const RTE_MBUF_F_TX_VLAN: u64 = 144115188075855872;
pub const RTE_MBUF_F_TX_OUTER_IP_CKSUM: u64 = 288230376151711744;
pub const RTE_MBUF_F_TX_OUTER_IPV4: u64 = 576460752303423488;
pub const RTE_MBUF_F_TX_OUTER_IPV6: u64 = 1152921504606846976;
pub const RTE_MBUF_F_TX_OFFLOAD_MASK: u64 = 2305840810190438400;
pub const RTE_MBUF_F_EXTERNAL: u64 = 2305843009213693952;
pub const RTE_MBUF_F_INDIRECT: u64 = 4611686018427387904;
pub const RTE_MBUF_PRIV_ALIGN: u32 = 8;
pub const RTE_MBUF_DEFAULT_DATAROOM: u32 = 2048;
pub const RTE_MBUF_DEFAULT_BUF_SIZE: u32 = 2176;
pub const RTE_MBUF_MAX_NB_SEGS: u32 = 65535;
pub const RTE_MBUF_PORT_INVALID: u32 = 65535;
pub const MBUF_INVALID_PORT: u32 = 65535;
pub const RTE_PKTMBUF_POOL_F_PINNED_EXT_BUF: u32 = 1;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    ) -> !;
}
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    const UNINIT: ::std::mem::MaybeUninit<sched_param> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_set_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
pub type unaligned_uint64_t = u64;
pub type unaligned_uint32_t = u32;
pub type unaligned_uint16_t = u16;
pub type phys_addr_t = u64;
pub type rte_iova_t = u64;
pub type RTE_MARKER = [*mut ::std::os::raw::c_void; 0usize];
pub type RTE_MARKER8 = [u8; 0usize];
pub type RTE_MARKER16 = [u16; 0usize];
pub type RTE_MARKER32 = [u32; 0usize];
pub type RTE_MARKER64 = [u64; 0usize];
extern "C" {
    pub fn rte_str_to_size(str_: *const ::std::os::raw::c_char) -> u64;
}
extern "C" {
    pub fn rte_exit(
        exit_code: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> !;
}
pub type rte_be16_t = u16;
pub type rte_be32_t = u32;
pub type rte_be64_t = u64;
pub type rte_le16_t = u16;
pub type rte_le32_t = u32;
pub type rte_le64_t = u64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_l2tpv2_common_hdr {
    pub __bindgen_anon_1: rte_l2tpv2_common_hdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_l2tpv2_common_hdr__bindgen_ty_1 {
    pub flags_version: rte_be16_t,
    pub __bindgen_anon_1: rte_l2tpv2_common_hdr__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct rte_l2tpv2_common_hdr__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_rte_l2tpv2_common_hdr__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_l2tpv2_common_hdr__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(rte_l2tpv2_common_hdr__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_l2tpv2_common_hdr__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(rte_l2tpv2_common_hdr__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl rte_l2tpv2_common_hdr__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ver(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_ver(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn res3(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_res3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn p(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn o(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_o(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn res2(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_res2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn s(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_s(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn res1(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn l(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_l(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn t(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_t(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ver: u16,
        res3: u16,
        p: u16,
        o: u16,
        res2: u16,
        s: u16,
        res1: u16,
        l: u16,
        t: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ver: u16 = unsafe { ::std::mem::transmute(ver) };
            ver as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let res3: u16 = unsafe { ::std::mem::transmute(res3) };
            res3 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let p: u16 = unsafe { ::std::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let o: u16 = unsafe { ::std::mem::transmute(o) };
            o as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let res2: u16 = unsafe { ::std::mem::transmute(res2) };
            res2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let s: u16 = unsafe { ::std::mem::transmute(s) };
            s as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let res1: u16 = unsafe { ::std::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let l: u16 = unsafe { ::std::mem::transmute(l) };
            l as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let t: u16 = unsafe { ::std::mem::transmute(t) };
            t as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_rte_l2tpv2_common_hdr__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_l2tpv2_common_hdr__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_l2tpv2_common_hdr__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(rte_l2tpv2_common_hdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_l2tpv2_common_hdr__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(rte_l2tpv2_common_hdr__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_common_hdr__bindgen_ty_1),
            "::",
            stringify!(flags_version)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_l2tpv2_common_hdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_l2tpv2_common_hdr>(),
        2usize,
        concat!("Size of: ", stringify!(rte_l2tpv2_common_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_l2tpv2_common_hdr>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_l2tpv2_common_hdr))
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_l2tpv2_msg_with_all_options {
    pub length: rte_be16_t,
    pub tunnel_id: rte_be16_t,
    pub session_id: rte_be16_t,
    pub ns: rte_be16_t,
    pub nr: rte_be16_t,
    pub offset_size: rte_be16_t,
    pub offset_padding: *mut u8,
}
#[test]
fn bindgen_test_layout_rte_l2tpv2_msg_with_all_options() {
    const UNINIT: ::std::mem::MaybeUninit<rte_l2tpv2_msg_with_all_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_l2tpv2_msg_with_all_options>(),
        20usize,
        concat!("Size of: ", stringify!(rte_l2tpv2_msg_with_all_options))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_l2tpv2_msg_with_all_options>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_l2tpv2_msg_with_all_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_with_all_options),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tunnel_id) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_with_all_options),
            "::",
            stringify!(tunnel_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_with_all_options),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ns) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_with_all_options),
            "::",
            stringify!(ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_with_all_options),
            "::",
            stringify!(nr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset_size) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_with_all_options),
            "::",
            stringify!(offset_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset_padding) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_with_all_options),
            "::",
            stringify!(offset_padding)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_l2tpv2_msg_without_length {
    pub tunnel_id: rte_be16_t,
    pub session_id: rte_be16_t,
    pub ns: rte_be16_t,
    pub nr: rte_be16_t,
    pub offset_size: rte_be16_t,
    pub offset_padding: *mut u8,
}
#[test]
fn bindgen_test_layout_rte_l2tpv2_msg_without_length() {
    const UNINIT: ::std::mem::MaybeUninit<rte_l2tpv2_msg_without_length> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_l2tpv2_msg_without_length>(),
        18usize,
        concat!("Size of: ", stringify!(rte_l2tpv2_msg_without_length))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_l2tpv2_msg_without_length>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_l2tpv2_msg_without_length))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tunnel_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_without_length),
            "::",
            stringify!(tunnel_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_without_length),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ns) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_without_length),
            "::",
            stringify!(ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nr) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_without_length),
            "::",
            stringify!(nr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_without_length),
            "::",
            stringify!(offset_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset_padding) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_without_length),
            "::",
            stringify!(offset_padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_l2tpv2_msg_without_ns_nr {
    pub length: rte_be16_t,
    pub tunnel_id: rte_be16_t,
    pub session_id: rte_be16_t,
    pub offset_size: rte_be16_t,
    pub offset_padding: *mut u8,
}
#[test]
fn bindgen_test_layout_rte_l2tpv2_msg_without_ns_nr() {
    const UNINIT: ::std::mem::MaybeUninit<rte_l2tpv2_msg_without_ns_nr> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_l2tpv2_msg_without_ns_nr>(),
        16usize,
        concat!("Size of: ", stringify!(rte_l2tpv2_msg_without_ns_nr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_l2tpv2_msg_without_ns_nr>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_l2tpv2_msg_without_ns_nr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_without_ns_nr),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tunnel_id) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_without_ns_nr),
            "::",
            stringify!(tunnel_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_without_ns_nr),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset_size) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_without_ns_nr),
            "::",
            stringify!(offset_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset_padding) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_without_ns_nr),
            "::",
            stringify!(offset_padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_l2tpv2_msg_without_offset {
    pub length: rte_be16_t,
    pub tunnel_id: rte_be16_t,
    pub session_id: rte_be16_t,
    pub ns: rte_be16_t,
    pub nr: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_l2tpv2_msg_without_offset() {
    const UNINIT: ::std::mem::MaybeUninit<rte_l2tpv2_msg_without_offset> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_l2tpv2_msg_without_offset>(),
        10usize,
        concat!("Size of: ", stringify!(rte_l2tpv2_msg_without_offset))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_l2tpv2_msg_without_offset>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_l2tpv2_msg_without_offset))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_without_offset),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tunnel_id) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_without_offset),
            "::",
            stringify!(tunnel_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_without_offset),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ns) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_without_offset),
            "::",
            stringify!(ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_without_offset),
            "::",
            stringify!(nr)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_l2tpv2_msg_with_offset {
    pub tunnel_id: rte_be16_t,
    pub session_id: rte_be16_t,
    pub offset_size: rte_be16_t,
    pub offset_padding: *mut u8,
}
#[test]
fn bindgen_test_layout_rte_l2tpv2_msg_with_offset() {
    const UNINIT: ::std::mem::MaybeUninit<rte_l2tpv2_msg_with_offset> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_l2tpv2_msg_with_offset>(),
        14usize,
        concat!("Size of: ", stringify!(rte_l2tpv2_msg_with_offset))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_l2tpv2_msg_with_offset>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_l2tpv2_msg_with_offset))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tunnel_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_with_offset),
            "::",
            stringify!(tunnel_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_with_offset),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_with_offset),
            "::",
            stringify!(offset_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset_padding) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_with_offset),
            "::",
            stringify!(offset_padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_l2tpv2_msg_with_ns_nr {
    pub tunnel_id: rte_be16_t,
    pub session_id: rte_be16_t,
    pub ns: rte_be16_t,
    pub nr: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_l2tpv2_msg_with_ns_nr() {
    const UNINIT: ::std::mem::MaybeUninit<rte_l2tpv2_msg_with_ns_nr> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_l2tpv2_msg_with_ns_nr>(),
        8usize,
        concat!("Size of: ", stringify!(rte_l2tpv2_msg_with_ns_nr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_l2tpv2_msg_with_ns_nr>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_l2tpv2_msg_with_ns_nr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tunnel_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_with_ns_nr),
            "::",
            stringify!(tunnel_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_with_ns_nr),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ns) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_with_ns_nr),
            "::",
            stringify!(ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nr) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_with_ns_nr),
            "::",
            stringify!(nr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_l2tpv2_msg_with_length {
    pub length: rte_be16_t,
    pub tunnel_id: rte_be16_t,
    pub session_id: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_l2tpv2_msg_with_length() {
    const UNINIT: ::std::mem::MaybeUninit<rte_l2tpv2_msg_with_length> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_l2tpv2_msg_with_length>(),
        6usize,
        concat!("Size of: ", stringify!(rte_l2tpv2_msg_with_length))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_l2tpv2_msg_with_length>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_l2tpv2_msg_with_length))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_with_length),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tunnel_id) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_with_length),
            "::",
            stringify!(tunnel_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_with_length),
            "::",
            stringify!(session_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_l2tpv2_msg_without_all_options {
    pub tunnel_id: rte_be16_t,
    pub session_id: rte_be16_t,
}
#[test]
fn bindgen_test_layout_rte_l2tpv2_msg_without_all_options() {
    const UNINIT: ::std::mem::MaybeUninit<rte_l2tpv2_msg_without_all_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_l2tpv2_msg_without_all_options>(),
        4usize,
        concat!("Size of: ", stringify!(rte_l2tpv2_msg_without_all_options))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_l2tpv2_msg_without_all_options>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(rte_l2tpv2_msg_without_all_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tunnel_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_without_all_options),
            "::",
            stringify!(tunnel_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_msg_without_all_options),
            "::",
            stringify!(session_id)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_l2tpv2_combined_msg_hdr {
    pub common: rte_l2tpv2_common_hdr,
    pub __bindgen_anon_1: rte_l2tpv2_combined_msg_hdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_l2tpv2_combined_msg_hdr__bindgen_ty_1 {
    pub type0: rte_l2tpv2_msg_with_all_options,
    pub type1: rte_l2tpv2_msg_without_length,
    pub type2: rte_l2tpv2_msg_without_ns_nr,
    pub type3: rte_l2tpv2_msg_without_offset,
    pub type4: rte_l2tpv2_msg_with_offset,
    pub type5: rte_l2tpv2_msg_with_ns_nr,
    pub type6: rte_l2tpv2_msg_with_length,
    pub type7: rte_l2tpv2_msg_without_all_options,
}
#[test]
fn bindgen_test_layout_rte_l2tpv2_combined_msg_hdr__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_l2tpv2_combined_msg_hdr__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_l2tpv2_combined_msg_hdr__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(rte_l2tpv2_combined_msg_hdr__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_l2tpv2_combined_msg_hdr__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_l2tpv2_combined_msg_hdr__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_combined_msg_hdr__bindgen_ty_1),
            "::",
            stringify!(type0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_combined_msg_hdr__bindgen_ty_1),
            "::",
            stringify!(type1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type2) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_combined_msg_hdr__bindgen_ty_1),
            "::",
            stringify!(type2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type3) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_combined_msg_hdr__bindgen_ty_1),
            "::",
            stringify!(type3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type4) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_combined_msg_hdr__bindgen_ty_1),
            "::",
            stringify!(type4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type5) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_combined_msg_hdr__bindgen_ty_1),
            "::",
            stringify!(type5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type6) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_combined_msg_hdr__bindgen_ty_1),
            "::",
            stringify!(type6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type7) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_combined_msg_hdr__bindgen_ty_1),
            "::",
            stringify!(type7)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_l2tpv2_combined_msg_hdr() {
    const UNINIT: ::std::mem::MaybeUninit<rte_l2tpv2_combined_msg_hdr> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_l2tpv2_combined_msg_hdr>(),
        26usize,
        concat!("Size of: ", stringify!(rte_l2tpv2_combined_msg_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_l2tpv2_combined_msg_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_l2tpv2_combined_msg_hdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).common) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_l2tpv2_combined_msg_hdr),
            "::",
            stringify!(common)
        )
    );
}
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub _prevchain: *mut *mut _IO_FILE,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._prevchain) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_prevchain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[test]
fn bindgen_test_layout__IO_cookie_io_functions_t() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_cookie_io_functions_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_cookie_io_functions_t>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_cookie_io_functions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(close)
        )
    );
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type va_list = __gnuc_va_list;
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::std::os::raw::c_void,
        __modes: *const ::std::os::raw::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __f: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::std::mem::MaybeUninit<random_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::std::mem::MaybeUninit<drand48_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: usize);
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchrnul(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcasestr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memmem(
        __haystack: *const ::std::os::raw::c_void,
        __haystacklen: usize,
        __needle: *const ::std::os::raw::c_void,
        __needlelen: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
pub type useconds_t = __useconds_t;
pub type socklen_t = __socklen_t;
extern "C" {
    pub fn access(
        __name: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faccessat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(
        __fd: ::std::os::raw::c_int,
        __offset: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> __off_t;
}
extern "C" {
    pub fn close(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn closefrom(__lowfd: ::std::os::raw::c_int);
}
extern "C" {
    pub fn read(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
    ) -> isize;
}
extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> isize;
}
extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pipe(__pipedes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
}
extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(
        __fd: ::std::os::raw::c_int,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchdir(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getcwd(__buf: *mut ::std::os::raw::c_char, __size: usize)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwd(__buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dup(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(__fd: ::std::os::raw::c_int, __fd2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __environ: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn execve(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fexecve(
        __fd: ::std::os::raw::c_int,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nice(__inc: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _exit(__status: ::std::os::raw::c_int) -> !;
}
pub const _PC_LINK_MAX: _bindgen_ty_1 = 0;
pub const _PC_MAX_CANON: _bindgen_ty_1 = 1;
pub const _PC_MAX_INPUT: _bindgen_ty_1 = 2;
pub const _PC_NAME_MAX: _bindgen_ty_1 = 3;
pub const _PC_PATH_MAX: _bindgen_ty_1 = 4;
pub const _PC_PIPE_BUF: _bindgen_ty_1 = 5;
pub const _PC_CHOWN_RESTRICTED: _bindgen_ty_1 = 6;
pub const _PC_NO_TRUNC: _bindgen_ty_1 = 7;
pub const _PC_VDISABLE: _bindgen_ty_1 = 8;
pub const _PC_SYNC_IO: _bindgen_ty_1 = 9;
pub const _PC_ASYNC_IO: _bindgen_ty_1 = 10;
pub const _PC_PRIO_IO: _bindgen_ty_1 = 11;
pub const _PC_SOCK_MAXBUF: _bindgen_ty_1 = 12;
pub const _PC_FILESIZEBITS: _bindgen_ty_1 = 13;
pub const _PC_REC_INCR_XFER_SIZE: _bindgen_ty_1 = 14;
pub const _PC_REC_MAX_XFER_SIZE: _bindgen_ty_1 = 15;
pub const _PC_REC_MIN_XFER_SIZE: _bindgen_ty_1 = 16;
pub const _PC_REC_XFER_ALIGN: _bindgen_ty_1 = 17;
pub const _PC_ALLOC_SIZE_MIN: _bindgen_ty_1 = 18;
pub const _PC_SYMLINK_MAX: _bindgen_ty_1 = 19;
pub const _PC_2_SYMLINKS: _bindgen_ty_1 = 20;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const _SC_ARG_MAX: _bindgen_ty_2 = 0;
pub const _SC_CHILD_MAX: _bindgen_ty_2 = 1;
pub const _SC_CLK_TCK: _bindgen_ty_2 = 2;
pub const _SC_NGROUPS_MAX: _bindgen_ty_2 = 3;
pub const _SC_OPEN_MAX: _bindgen_ty_2 = 4;
pub const _SC_STREAM_MAX: _bindgen_ty_2 = 5;
pub const _SC_TZNAME_MAX: _bindgen_ty_2 = 6;
pub const _SC_JOB_CONTROL: _bindgen_ty_2 = 7;
pub const _SC_SAVED_IDS: _bindgen_ty_2 = 8;
pub const _SC_REALTIME_SIGNALS: _bindgen_ty_2 = 9;
pub const _SC_PRIORITY_SCHEDULING: _bindgen_ty_2 = 10;
pub const _SC_TIMERS: _bindgen_ty_2 = 11;
pub const _SC_ASYNCHRONOUS_IO: _bindgen_ty_2 = 12;
pub const _SC_PRIORITIZED_IO: _bindgen_ty_2 = 13;
pub const _SC_SYNCHRONIZED_IO: _bindgen_ty_2 = 14;
pub const _SC_FSYNC: _bindgen_ty_2 = 15;
pub const _SC_MAPPED_FILES: _bindgen_ty_2 = 16;
pub const _SC_MEMLOCK: _bindgen_ty_2 = 17;
pub const _SC_MEMLOCK_RANGE: _bindgen_ty_2 = 18;
pub const _SC_MEMORY_PROTECTION: _bindgen_ty_2 = 19;
pub const _SC_MESSAGE_PASSING: _bindgen_ty_2 = 20;
pub const _SC_SEMAPHORES: _bindgen_ty_2 = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: _bindgen_ty_2 = 22;
pub const _SC_AIO_LISTIO_MAX: _bindgen_ty_2 = 23;
pub const _SC_AIO_MAX: _bindgen_ty_2 = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: _bindgen_ty_2 = 25;
pub const _SC_DELAYTIMER_MAX: _bindgen_ty_2 = 26;
pub const _SC_MQ_OPEN_MAX: _bindgen_ty_2 = 27;
pub const _SC_MQ_PRIO_MAX: _bindgen_ty_2 = 28;
pub const _SC_VERSION: _bindgen_ty_2 = 29;
pub const _SC_PAGESIZE: _bindgen_ty_2 = 30;
pub const _SC_RTSIG_MAX: _bindgen_ty_2 = 31;
pub const _SC_SEM_NSEMS_MAX: _bindgen_ty_2 = 32;
pub const _SC_SEM_VALUE_MAX: _bindgen_ty_2 = 33;
pub const _SC_SIGQUEUE_MAX: _bindgen_ty_2 = 34;
pub const _SC_TIMER_MAX: _bindgen_ty_2 = 35;
pub const _SC_BC_BASE_MAX: _bindgen_ty_2 = 36;
pub const _SC_BC_DIM_MAX: _bindgen_ty_2 = 37;
pub const _SC_BC_SCALE_MAX: _bindgen_ty_2 = 38;
pub const _SC_BC_STRING_MAX: _bindgen_ty_2 = 39;
pub const _SC_COLL_WEIGHTS_MAX: _bindgen_ty_2 = 40;
pub const _SC_EQUIV_CLASS_MAX: _bindgen_ty_2 = 41;
pub const _SC_EXPR_NEST_MAX: _bindgen_ty_2 = 42;
pub const _SC_LINE_MAX: _bindgen_ty_2 = 43;
pub const _SC_RE_DUP_MAX: _bindgen_ty_2 = 44;
pub const _SC_CHARCLASS_NAME_MAX: _bindgen_ty_2 = 45;
pub const _SC_2_VERSION: _bindgen_ty_2 = 46;
pub const _SC_2_C_BIND: _bindgen_ty_2 = 47;
pub const _SC_2_C_DEV: _bindgen_ty_2 = 48;
pub const _SC_2_FORT_DEV: _bindgen_ty_2 = 49;
pub const _SC_2_FORT_RUN: _bindgen_ty_2 = 50;
pub const _SC_2_SW_DEV: _bindgen_ty_2 = 51;
pub const _SC_2_LOCALEDEF: _bindgen_ty_2 = 52;
pub const _SC_PII: _bindgen_ty_2 = 53;
pub const _SC_PII_XTI: _bindgen_ty_2 = 54;
pub const _SC_PII_SOCKET: _bindgen_ty_2 = 55;
pub const _SC_PII_INTERNET: _bindgen_ty_2 = 56;
pub const _SC_PII_OSI: _bindgen_ty_2 = 57;
pub const _SC_POLL: _bindgen_ty_2 = 58;
pub const _SC_SELECT: _bindgen_ty_2 = 59;
pub const _SC_UIO_MAXIOV: _bindgen_ty_2 = 60;
pub const _SC_IOV_MAX: _bindgen_ty_2 = 60;
pub const _SC_PII_INTERNET_STREAM: _bindgen_ty_2 = 61;
pub const _SC_PII_INTERNET_DGRAM: _bindgen_ty_2 = 62;
pub const _SC_PII_OSI_COTS: _bindgen_ty_2 = 63;
pub const _SC_PII_OSI_CLTS: _bindgen_ty_2 = 64;
pub const _SC_PII_OSI_M: _bindgen_ty_2 = 65;
pub const _SC_T_IOV_MAX: _bindgen_ty_2 = 66;
pub const _SC_THREADS: _bindgen_ty_2 = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: _bindgen_ty_2 = 68;
pub const _SC_GETGR_R_SIZE_MAX: _bindgen_ty_2 = 69;
pub const _SC_GETPW_R_SIZE_MAX: _bindgen_ty_2 = 70;
pub const _SC_LOGIN_NAME_MAX: _bindgen_ty_2 = 71;
pub const _SC_TTY_NAME_MAX: _bindgen_ty_2 = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: _bindgen_ty_2 = 73;
pub const _SC_THREAD_KEYS_MAX: _bindgen_ty_2 = 74;
pub const _SC_THREAD_STACK_MIN: _bindgen_ty_2 = 75;
pub const _SC_THREAD_THREADS_MAX: _bindgen_ty_2 = 76;
pub const _SC_THREAD_ATTR_STACKADDR: _bindgen_ty_2 = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: _bindgen_ty_2 = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: _bindgen_ty_2 = 79;
pub const _SC_THREAD_PRIO_INHERIT: _bindgen_ty_2 = 80;
pub const _SC_THREAD_PRIO_PROTECT: _bindgen_ty_2 = 81;
pub const _SC_THREAD_PROCESS_SHARED: _bindgen_ty_2 = 82;
pub const _SC_NPROCESSORS_CONF: _bindgen_ty_2 = 83;
pub const _SC_NPROCESSORS_ONLN: _bindgen_ty_2 = 84;
pub const _SC_PHYS_PAGES: _bindgen_ty_2 = 85;
pub const _SC_AVPHYS_PAGES: _bindgen_ty_2 = 86;
pub const _SC_ATEXIT_MAX: _bindgen_ty_2 = 87;
pub const _SC_PASS_MAX: _bindgen_ty_2 = 88;
pub const _SC_XOPEN_VERSION: _bindgen_ty_2 = 89;
pub const _SC_XOPEN_XCU_VERSION: _bindgen_ty_2 = 90;
pub const _SC_XOPEN_UNIX: _bindgen_ty_2 = 91;
pub const _SC_XOPEN_CRYPT: _bindgen_ty_2 = 92;
pub const _SC_XOPEN_ENH_I18N: _bindgen_ty_2 = 93;
pub const _SC_XOPEN_SHM: _bindgen_ty_2 = 94;
pub const _SC_2_CHAR_TERM: _bindgen_ty_2 = 95;
pub const _SC_2_C_VERSION: _bindgen_ty_2 = 96;
pub const _SC_2_UPE: _bindgen_ty_2 = 97;
pub const _SC_XOPEN_XPG2: _bindgen_ty_2 = 98;
pub const _SC_XOPEN_XPG3: _bindgen_ty_2 = 99;
pub const _SC_XOPEN_XPG4: _bindgen_ty_2 = 100;
pub const _SC_CHAR_BIT: _bindgen_ty_2 = 101;
pub const _SC_CHAR_MAX: _bindgen_ty_2 = 102;
pub const _SC_CHAR_MIN: _bindgen_ty_2 = 103;
pub const _SC_INT_MAX: _bindgen_ty_2 = 104;
pub const _SC_INT_MIN: _bindgen_ty_2 = 105;
pub const _SC_LONG_BIT: _bindgen_ty_2 = 106;
pub const _SC_WORD_BIT: _bindgen_ty_2 = 107;
pub const _SC_MB_LEN_MAX: _bindgen_ty_2 = 108;
pub const _SC_NZERO: _bindgen_ty_2 = 109;
pub const _SC_SSIZE_MAX: _bindgen_ty_2 = 110;
pub const _SC_SCHAR_MAX: _bindgen_ty_2 = 111;
pub const _SC_SCHAR_MIN: _bindgen_ty_2 = 112;
pub const _SC_SHRT_MAX: _bindgen_ty_2 = 113;
pub const _SC_SHRT_MIN: _bindgen_ty_2 = 114;
pub const _SC_UCHAR_MAX: _bindgen_ty_2 = 115;
pub const _SC_UINT_MAX: _bindgen_ty_2 = 116;
pub const _SC_ULONG_MAX: _bindgen_ty_2 = 117;
pub const _SC_USHRT_MAX: _bindgen_ty_2 = 118;
pub const _SC_NL_ARGMAX: _bindgen_ty_2 = 119;
pub const _SC_NL_LANGMAX: _bindgen_ty_2 = 120;
pub const _SC_NL_MSGMAX: _bindgen_ty_2 = 121;
pub const _SC_NL_NMAX: _bindgen_ty_2 = 122;
pub const _SC_NL_SETMAX: _bindgen_ty_2 = 123;
pub const _SC_NL_TEXTMAX: _bindgen_ty_2 = 124;
pub const _SC_XBS5_ILP32_OFF32: _bindgen_ty_2 = 125;
pub const _SC_XBS5_ILP32_OFFBIG: _bindgen_ty_2 = 126;
pub const _SC_XBS5_LP64_OFF64: _bindgen_ty_2 = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: _bindgen_ty_2 = 128;
pub const _SC_XOPEN_LEGACY: _bindgen_ty_2 = 129;
pub const _SC_XOPEN_REALTIME: _bindgen_ty_2 = 130;
pub const _SC_XOPEN_REALTIME_THREADS: _bindgen_ty_2 = 131;
pub const _SC_ADVISORY_INFO: _bindgen_ty_2 = 132;
pub const _SC_BARRIERS: _bindgen_ty_2 = 133;
pub const _SC_BASE: _bindgen_ty_2 = 134;
pub const _SC_C_LANG_SUPPORT: _bindgen_ty_2 = 135;
pub const _SC_C_LANG_SUPPORT_R: _bindgen_ty_2 = 136;
pub const _SC_CLOCK_SELECTION: _bindgen_ty_2 = 137;
pub const _SC_CPUTIME: _bindgen_ty_2 = 138;
pub const _SC_THREAD_CPUTIME: _bindgen_ty_2 = 139;
pub const _SC_DEVICE_IO: _bindgen_ty_2 = 140;
pub const _SC_DEVICE_SPECIFIC: _bindgen_ty_2 = 141;
pub const _SC_DEVICE_SPECIFIC_R: _bindgen_ty_2 = 142;
pub const _SC_FD_MGMT: _bindgen_ty_2 = 143;
pub const _SC_FIFO: _bindgen_ty_2 = 144;
pub const _SC_PIPE: _bindgen_ty_2 = 145;
pub const _SC_FILE_ATTRIBUTES: _bindgen_ty_2 = 146;
pub const _SC_FILE_LOCKING: _bindgen_ty_2 = 147;
pub const _SC_FILE_SYSTEM: _bindgen_ty_2 = 148;
pub const _SC_MONOTONIC_CLOCK: _bindgen_ty_2 = 149;
pub const _SC_MULTI_PROCESS: _bindgen_ty_2 = 150;
pub const _SC_SINGLE_PROCESS: _bindgen_ty_2 = 151;
pub const _SC_NETWORKING: _bindgen_ty_2 = 152;
pub const _SC_READER_WRITER_LOCKS: _bindgen_ty_2 = 153;
pub const _SC_SPIN_LOCKS: _bindgen_ty_2 = 154;
pub const _SC_REGEXP: _bindgen_ty_2 = 155;
pub const _SC_REGEX_VERSION: _bindgen_ty_2 = 156;
pub const _SC_SHELL: _bindgen_ty_2 = 157;
pub const _SC_SIGNALS: _bindgen_ty_2 = 158;
pub const _SC_SPAWN: _bindgen_ty_2 = 159;
pub const _SC_SPORADIC_SERVER: _bindgen_ty_2 = 160;
pub const _SC_THREAD_SPORADIC_SERVER: _bindgen_ty_2 = 161;
pub const _SC_SYSTEM_DATABASE: _bindgen_ty_2 = 162;
pub const _SC_SYSTEM_DATABASE_R: _bindgen_ty_2 = 163;
pub const _SC_TIMEOUTS: _bindgen_ty_2 = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: _bindgen_ty_2 = 165;
pub const _SC_USER_GROUPS: _bindgen_ty_2 = 166;
pub const _SC_USER_GROUPS_R: _bindgen_ty_2 = 167;
pub const _SC_2_PBS: _bindgen_ty_2 = 168;
pub const _SC_2_PBS_ACCOUNTING: _bindgen_ty_2 = 169;
pub const _SC_2_PBS_LOCATE: _bindgen_ty_2 = 170;
pub const _SC_2_PBS_MESSAGE: _bindgen_ty_2 = 171;
pub const _SC_2_PBS_TRACK: _bindgen_ty_2 = 172;
pub const _SC_SYMLOOP_MAX: _bindgen_ty_2 = 173;
pub const _SC_STREAMS: _bindgen_ty_2 = 174;
pub const _SC_2_PBS_CHECKPOINT: _bindgen_ty_2 = 175;
pub const _SC_V6_ILP32_OFF32: _bindgen_ty_2 = 176;
pub const _SC_V6_ILP32_OFFBIG: _bindgen_ty_2 = 177;
pub const _SC_V6_LP64_OFF64: _bindgen_ty_2 = 178;
pub const _SC_V6_LPBIG_OFFBIG: _bindgen_ty_2 = 179;
pub const _SC_HOST_NAME_MAX: _bindgen_ty_2 = 180;
pub const _SC_TRACE: _bindgen_ty_2 = 181;
pub const _SC_TRACE_EVENT_FILTER: _bindgen_ty_2 = 182;
pub const _SC_TRACE_INHERIT: _bindgen_ty_2 = 183;
pub const _SC_TRACE_LOG: _bindgen_ty_2 = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: _bindgen_ty_2 = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: _bindgen_ty_2 = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: _bindgen_ty_2 = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: _bindgen_ty_2 = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: _bindgen_ty_2 = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: _bindgen_ty_2 = 190;
pub const _SC_LEVEL2_CACHE_SIZE: _bindgen_ty_2 = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: _bindgen_ty_2 = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: _bindgen_ty_2 = 193;
pub const _SC_LEVEL3_CACHE_SIZE: _bindgen_ty_2 = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: _bindgen_ty_2 = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: _bindgen_ty_2 = 196;
pub const _SC_LEVEL4_CACHE_SIZE: _bindgen_ty_2 = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: _bindgen_ty_2 = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: _bindgen_ty_2 = 199;
pub const _SC_IPV6: _bindgen_ty_2 = 235;
pub const _SC_RAW_SOCKETS: _bindgen_ty_2 = 236;
pub const _SC_V7_ILP32_OFF32: _bindgen_ty_2 = 237;
pub const _SC_V7_ILP32_OFFBIG: _bindgen_ty_2 = 238;
pub const _SC_V7_LP64_OFF64: _bindgen_ty_2 = 239;
pub const _SC_V7_LPBIG_OFFBIG: _bindgen_ty_2 = 240;
pub const _SC_SS_REPL_MAX: _bindgen_ty_2 = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: _bindgen_ty_2 = 242;
pub const _SC_TRACE_NAME_MAX: _bindgen_ty_2 = 243;
pub const _SC_TRACE_SYS_MAX: _bindgen_ty_2 = 244;
pub const _SC_TRACE_USER_EVENT_MAX: _bindgen_ty_2 = 245;
pub const _SC_XOPEN_STREAMS: _bindgen_ty_2 = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: _bindgen_ty_2 = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: _bindgen_ty_2 = 248;
pub const _SC_MINSIGSTKSZ: _bindgen_ty_2 = 249;
pub const _SC_SIGSTKSZ: _bindgen_ty_2 = 250;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const _CS_PATH: _bindgen_ty_3 = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 1;
pub const _CS_GNU_LIBC_VERSION: _bindgen_ty_3 = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: _bindgen_ty_3 = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 5;
pub const _CS_LFS_CFLAGS: _bindgen_ty_3 = 1000;
pub const _CS_LFS_LDFLAGS: _bindgen_ty_3 = 1001;
pub const _CS_LFS_LIBS: _bindgen_ty_3 = 1002;
pub const _CS_LFS_LINTFLAGS: _bindgen_ty_3 = 1003;
pub const _CS_LFS64_CFLAGS: _bindgen_ty_3 = 1004;
pub const _CS_LFS64_LDFLAGS: _bindgen_ty_3 = 1005;
pub const _CS_LFS64_LIBS: _bindgen_ty_3 = 1006;
pub const _CS_LFS64_LINTFLAGS: _bindgen_ty_3 = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: _bindgen_ty_3 = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: _bindgen_ty_3 = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: _bindgen_ty_3 = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1147;
pub const _CS_V6_ENV: _bindgen_ty_3 = 1148;
pub const _CS_V7_ENV: _bindgen_ty_3 = 1149;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pathconf(
        __path: *const ::std::os::raw::c_char,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fpathconf(
        __fd: ::std::os::raw::c_int,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn confstr(
        __name: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> usize;
}
extern "C" {
    pub fn getpid() -> __pid_t;
}
extern "C" {
    pub fn getppid() -> __pid_t;
}
extern "C" {
    pub fn getpgrp() -> __pid_t;
}
extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpgrp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsid() -> __pid_t;
}
extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getuid() -> __uid_t;
}
extern "C" {
    pub fn geteuid() -> __uid_t;
}
extern "C" {
    pub fn getgid() -> __gid_t;
}
extern "C" {
    pub fn getegid() -> __gid_t;
}
extern "C" {
    pub fn getgroups(__size: ::std::os::raw::c_int, __list: *mut __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setegid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fork() -> __pid_t;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isatty(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(
        __fromfd: ::std::os::raw::c_int,
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    pub fn symlinkat(
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlinkat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    pub fn unlink(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(
        __fd: ::std::os::raw::c_int,
        __name: *const ::std::os::raw::c_char,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetpgrp(__fd: ::std::os::raw::c_int) -> __pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fd: ::std::os::raw::c_int, __pgrp_id: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getlogin_r(
        __name: *mut ::std::os::raw::c_char,
        __name_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setlogin(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn getopt(
        ___argc: ::std::os::raw::c_int,
        ___argv: *const *mut ::std::os::raw::c_char,
        __shortopts: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(__name: *mut ::std::os::raw::c_char, __len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostid(__id: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdomainname(
        __name: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vhangup() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn revoke(__file: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn profil(
        __sample_buffer: *mut ::std::os::raw::c_ushort,
        __size: usize,
        __offset: usize,
        __scale: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acct(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn daemon(
        __nochdir: ::std::os::raw::c_int,
        __noclose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chroot(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpass(__prompt: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn truncate(
        __file: *const ::std::os::raw::c_char,
        __length: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: __off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brk(__addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sbrk(__delta: isize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn syscall(__sysno: ::std::os::raw::c_long, ...) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdatasync(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypt(
        __key: *const ::std::os::raw::c_char,
        __salt: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getentropy(
        __buffer: *mut ::std::os::raw::c_void,
        __length: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::std::mem::MaybeUninit<itimerspec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type rte_uuid_t = [::std::os::raw::c_uchar; 16usize];
extern "C" {
    pub fn rte_uuid_is_null(uu: *mut ::std::os::raw::c_uchar) -> bool;
}
extern "C" {
    pub fn rte_uuid_compare(
        a: *mut ::std::os::raw::c_uchar,
        b: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_uuid_parse(
        in_: *const ::std::os::raw::c_char,
        uu: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_uuid_unparse(
        uu: *mut ::std::os::raw::c_uchar,
        out: *mut ::std::os::raw::c_char,
        len: usize,
    );
}
pub const rte_intr_mode_RTE_INTR_MODE_NONE: rte_intr_mode = 0;
pub const rte_intr_mode_RTE_INTR_MODE_LEGACY: rte_intr_mode = 1;
pub const rte_intr_mode_RTE_INTR_MODE_MSI: rte_intr_mode = 2;
pub const rte_intr_mode_RTE_INTR_MODE_MSIX: rte_intr_mode = 3;
pub type rte_intr_mode = ::std::os::raw::c_uint;
pub const rte_proc_type_t_RTE_PROC_AUTO: rte_proc_type_t = -1;
pub const rte_proc_type_t_RTE_PROC_PRIMARY: rte_proc_type_t = 0;
pub const rte_proc_type_t_RTE_PROC_SECONDARY: rte_proc_type_t = 1;
pub const rte_proc_type_t_RTE_PROC_INVALID: rte_proc_type_t = 2;
pub type rte_proc_type_t = ::std::os::raw::c_int;
extern "C" {
    pub fn rte_eal_process_type() -> rte_proc_type_t;
}
extern "C" {
    pub fn rte_eal_iopl_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eal_init(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eal_cleanup() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eal_primary_proc_alive(
        config_file_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mp_disable() -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mp_msg {
    pub name: [::std::os::raw::c_char; 64usize],
    pub len_param: ::std::os::raw::c_int,
    pub num_fds: ::std::os::raw::c_int,
    pub param: [u8; 256usize],
    pub fds: [::std::os::raw::c_int; 253usize],
}
#[test]
fn bindgen_test_layout_rte_mp_msg() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mp_msg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mp_msg>(),
        1340usize,
        concat!("Size of: ", stringify!(rte_mp_msg))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mp_msg>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mp_msg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_msg),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len_param) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_msg),
            "::",
            stringify!(len_param)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_fds) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_msg),
            "::",
            stringify!(num_fds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).param) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_msg),
            "::",
            stringify!(param)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_msg),
            "::",
            stringify!(fds)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mp_reply {
    pub nb_sent: ::std::os::raw::c_int,
    pub nb_received: ::std::os::raw::c_int,
    pub msgs: *mut rte_mp_msg,
}
#[test]
fn bindgen_test_layout_rte_mp_reply() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mp_reply> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mp_reply>(),
        16usize,
        concat!("Size of: ", stringify!(rte_mp_reply))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mp_reply>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mp_reply))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_sent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_reply),
            "::",
            stringify!(nb_sent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_received) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_reply),
            "::",
            stringify!(nb_received)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_reply),
            "::",
            stringify!(msgs)
        )
    );
}
pub type rte_mp_t = ::std::option::Option<
    unsafe extern "C" fn(
        msg: *const rte_mp_msg,
        peer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_mp_async_reply_t = ::std::option::Option<
    unsafe extern "C" fn(
        request: *const rte_mp_msg,
        reply: *const rte_mp_reply,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rte_mp_action_register(
        name: *const ::std::os::raw::c_char,
        action: rte_mp_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mp_action_unregister(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rte_mp_sendmsg(msg: *mut rte_mp_msg) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mp_request_sync(
        req: *mut rte_mp_msg,
        reply: *mut rte_mp_reply,
        ts: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mp_request_async(
        req: *mut rte_mp_msg,
        ts: *const timespec,
        clb: rte_mp_async_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mp_reply(
        msg: *mut rte_mp_msg,
        peer: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub type rte_usage_hook_t =
    ::std::option::Option<unsafe extern "C" fn(prgname: *const ::std::os::raw::c_char)>;
extern "C" {
    pub fn rte_set_application_usage_hook(usage_func: rte_usage_hook_t) -> rte_usage_hook_t;
}
extern "C" {
    pub fn rte_eal_has_hugepages() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eal_has_pci() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eal_create_uio_dev() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eal_vfio_intr_mode() -> rte_intr_mode;
}
extern "C" {
    pub fn rte_eal_vfio_get_vf_token(vf_token: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn rte_sys_gettid() -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut per_lcore__thread_id: ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eal_get_baseaddr() -> u64;
}
pub const rte_iova_mode_RTE_IOVA_DC: rte_iova_mode = 0;
pub const rte_iova_mode_RTE_IOVA_PA: rte_iova_mode = 1;
pub const rte_iova_mode_RTE_IOVA_VA: rte_iova_mode = 2;
pub type rte_iova_mode = ::std::os::raw::c_uint;
extern "C" {
    pub fn rte_eal_iova_mode() -> rte_iova_mode;
}
extern "C" {
    pub fn rte_eal_mbuf_user_pool_ops() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rte_eal_get_runtime_dir() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rte_eal_parse_coremask(
        coremask: *const ::std::os::raw::c_char,
        cores: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<imaxdiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub const rte_lcore_state_t_WAIT: rte_lcore_state_t = 0;
pub const rte_lcore_state_t_RUNNING: rte_lcore_state_t = 1;
pub type rte_lcore_state_t = ::std::os::raw::c_uint;
pub type lcore_function_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rte_eal_remote_launch(
        f: lcore_function_t,
        arg: *mut ::std::os::raw::c_void,
        worker_id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub const rte_rmt_call_main_t_SKIP_MAIN: rte_rmt_call_main_t = 0;
pub const rte_rmt_call_main_t_CALL_MAIN: rte_rmt_call_main_t = 1;
pub type rte_rmt_call_main_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn rte_eal_mp_remote_launch(
        f: lcore_function_t,
        arg: *mut ::std::os::raw::c_void,
        call_main: rte_rmt_call_main_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eal_get_lcore_state(worker_id: ::std::os::raw::c_uint) -> rte_lcore_state_t;
}
extern "C" {
    pub fn rte_eal_wait_lcore(worker_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eal_mp_wait_lcore();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_thread_t {
    pub opaque_id: usize,
}
#[test]
fn bindgen_test_layout_rte_thread_t() {
    const UNINIT: ::std::mem::MaybeUninit<rte_thread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_thread_t>(),
        8usize,
        concat!("Size of: ", stringify!(rte_thread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_thread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_thread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_thread_t),
            "::",
            stringify!(opaque_id)
        )
    );
}
pub type rte_thread_func =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void) -> u32>;
pub const rte_thread_priority_RTE_THREAD_PRIORITY_NORMAL: rte_thread_priority = 0;
pub const rte_thread_priority_RTE_THREAD_PRIORITY_REALTIME_CRITICAL: rte_thread_priority = 1;
pub type rte_thread_priority = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_thread_attr_t {
    pub priority: rte_thread_priority,
}
#[test]
fn bindgen_test_layout_rte_thread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<rte_thread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_thread_attr_t>(),
        4usize,
        concat!("Size of: ", stringify!(rte_thread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_thread_attr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_thread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_thread_attr_t),
            "::",
            stringify!(priority)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eal_tls_key {
    _unused: [u8; 0],
}
pub type rte_thread_key = *mut eal_tls_key;
extern "C" {
    pub fn rte_thread_create(
        thread_id: *mut rte_thread_t,
        thread_attr: *const rte_thread_attr_t,
        thread_func: rte_thread_func,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_thread_create_control(
        thread: *mut rte_thread_t,
        name: *const ::std::os::raw::c_char,
        thread_func: rte_thread_func,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_thread_create_internal_control(
        id: *mut rte_thread_t,
        name: *const ::std::os::raw::c_char,
        func: rte_thread_func,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_thread_join(thread_id: rte_thread_t, value_ptr: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_thread_detach(thread_id: rte_thread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_thread_self() -> rte_thread_t;
}
extern "C" {
    pub fn rte_thread_set_name(thread_id: rte_thread_t, thread_name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rte_thread_set_prefixed_name(id: rte_thread_t, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rte_thread_equal(t1: rte_thread_t, t2: rte_thread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_thread_attr_init(attr: *mut rte_thread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_thread_attr_set_priority(
        thread_attr: *mut rte_thread_attr_t,
        priority: rte_thread_priority,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_thread_get_priority(
        thread_id: rte_thread_t,
        priority: *mut rte_thread_priority,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_thread_set_priority(
        thread_id: rte_thread_t,
        priority: rte_thread_priority,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_thread_key_create(
        key: *mut rte_thread_key,
        destructor: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_thread_key_delete(key: rte_thread_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_thread_value_set(
        key: rte_thread_key,
        value: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_thread_value_get(key: rte_thread_key) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub static mut per_lcore__lcore_id: ::std::os::raw::c_uint;
}
pub const rte_lcore_role_t_ROLE_RTE: rte_lcore_role_t = 0;
pub const rte_lcore_role_t_ROLE_OFF: rte_lcore_role_t = 1;
pub const rte_lcore_role_t_ROLE_SERVICE: rte_lcore_role_t = 2;
pub const rte_lcore_role_t_ROLE_NON_EAL: rte_lcore_role_t = 3;
pub type rte_lcore_role_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn rte_eal_lcore_role(lcore_id: ::std::os::raw::c_uint) -> rte_lcore_role_t;
}
extern "C" {
    pub fn rte_lcore_has_role(
        lcore_id: ::std::os::raw::c_uint,
        role: rte_lcore_role_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_get_main_lcore() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_lcore_count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_lcore_index(lcore_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_socket_id() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_socket_count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_socket_id_by_idx(idx: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lcore_to_socket_id(lcore_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_lcore_to_cpu_id(lcore_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lcore_is_enabled(lcore_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_get_next_lcore(
        i: ::std::os::raw::c_uint,
        skip_main: ::std::os::raw::c_int,
        wrap: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
pub type rte_lcore_init_cb = ::std::option::Option<
    unsafe extern "C" fn(
        lcore_id: ::std::os::raw::c_uint,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_lcore_uninit_cb = ::std::option::Option<
    unsafe extern "C" fn(lcore_id: ::std::os::raw::c_uint, arg: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn rte_lcore_callback_register(
        name: *const ::std::os::raw::c_char,
        init: rte_lcore_init_cb,
        uninit: rte_lcore_uninit_cb,
        arg: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rte_lcore_callback_unregister(handle: *mut ::std::os::raw::c_void);
}
pub type rte_lcore_iterate_cb = ::std::option::Option<
    unsafe extern "C" fn(
        lcore_id: ::std::os::raw::c_uint,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rte_lcore_iterate(
        cb: rte_lcore_iterate_cb,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_lcore_usage {
    pub total_cycles: u64,
    pub busy_cycles: u64,
}
#[test]
fn bindgen_test_layout_rte_lcore_usage() {
    const UNINIT: ::std::mem::MaybeUninit<rte_lcore_usage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_lcore_usage>(),
        16usize,
        concat!("Size of: ", stringify!(rte_lcore_usage))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_lcore_usage>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_lcore_usage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_cycles) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_lcore_usage),
            "::",
            stringify!(total_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).busy_cycles) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_lcore_usage),
            "::",
            stringify!(busy_cycles)
        )
    );
}
pub type rte_lcore_usage_cb = ::std::option::Option<
    unsafe extern "C" fn(
        lcore_id: ::std::os::raw::c_uint,
        usage: *mut rte_lcore_usage,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rte_lcore_register_usage_cb(cb: rte_lcore_usage_cb);
}
extern "C" {
    pub fn rte_lcore_dump(f: *mut FILE);
}
extern "C" {
    pub fn rte_thread_register() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_thread_unregister();
}
pub type __m64 = [::std::os::raw::c_longlong; 1usize];
pub type __v1di = [::std::os::raw::c_longlong; 1usize];
pub type __v2si = [::std::os::raw::c_int; 2usize];
pub type __v4hi = [::std::os::raw::c_short; 4usize];
pub type __v8qi = [::std::os::raw::c_char; 8usize];
pub type __v4si = [::std::os::raw::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __m128_u = [f32; 4usize];
pub type __v4su = [::std::os::raw::c_uint; 4usize];
extern "C" {
    pub fn _mm_sfence();
}
extern "C" {
    pub fn _mm_getcsr() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _mm_setcsr(__i: ::std::os::raw::c_uint);
}
pub type __m128d = [f64; 2usize];
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __m128d_u = [f64; 2usize];
pub type __m128i_u = [::std::os::raw::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [::std::os::raw::c_longlong; 2usize];
pub type __v8hi = [::std::os::raw::c_short; 8usize];
pub type __v16qi = [::std::os::raw::c_char; 16usize];
pub type __v2du = [::std::os::raw::c_ulonglong; 2usize];
pub type __v8hu = [::std::os::raw::c_ushort; 8usize];
pub type __v16qu = [::std::os::raw::c_uchar; 16usize];
pub type __v16qs = [::std::os::raw::c_schar; 16usize];
pub type __v8hf = [__BindgenFloat16; 8usize];
pub type __m128h = [__BindgenFloat16; 8usize];
pub type __m128h_u = [__BindgenFloat16; 8usize];
pub type __v8bf = u128;
pub type __m128bh = u128;
extern "C" {
    pub fn _mm_clflush(__p: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn _mm_lfence();
}
extern "C" {
    pub fn _mm_mfence();
}
extern "C" {
    pub fn _mm_pause();
}
pub type rte_memory_order = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_atomic16_t {
    pub cnt: i16,
}
#[test]
fn bindgen_test_layout_rte_atomic16_t() {
    const UNINIT: ::std::mem::MaybeUninit<rte_atomic16_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_atomic16_t>(),
        2usize,
        concat!("Size of: ", stringify!(rte_atomic16_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_atomic16_t>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_atomic16_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cnt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_atomic16_t),
            "::",
            stringify!(cnt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_atomic32_t {
    pub cnt: i32,
}
#[test]
fn bindgen_test_layout_rte_atomic32_t() {
    const UNINIT: ::std::mem::MaybeUninit<rte_atomic32_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_atomic32_t>(),
        4usize,
        concat!("Size of: ", stringify!(rte_atomic32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_atomic32_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_atomic32_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cnt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_atomic32_t),
            "::",
            stringify!(cnt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_atomic64_t {
    pub cnt: i64,
}
#[test]
fn bindgen_test_layout_rte_atomic64_t() {
    const UNINIT: ::std::mem::MaybeUninit<rte_atomic64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_atomic64_t>(),
        8usize,
        concat!("Size of: ", stringify!(rte_atomic64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_atomic64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_atomic64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cnt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_atomic64_t),
            "::",
            stringify!(cnt)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct rte_int128_t {
    pub __bindgen_anon_1: rte_int128_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union rte_int128_t__bindgen_ty_1 {
    pub val: [u64; 2usize],
    pub int128: i128,
}
#[test]
fn bindgen_test_layout_rte_int128_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_int128_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_int128_t__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_int128_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_int128_t__bindgen_ty_1>(),
        16usize,
        concat!("Alignment of ", stringify!(rte_int128_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_int128_t__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int128) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_int128_t__bindgen_ty_1),
            "::",
            stringify!(int128)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_int128_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_int128_t>(),
        16usize,
        concat!("Size of: ", stringify!(rte_int128_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_int128_t>(),
        16usize,
        concat!("Alignment of ", stringify!(rte_int128_t))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_spinlock_t {
    pub locked: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rte_spinlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<rte_spinlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_spinlock_t>(),
        4usize,
        concat!("Size of: ", stringify!(rte_spinlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_spinlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_spinlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locked) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_spinlock_t),
            "::",
            stringify!(locked)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_spinlock_recursive_t {
    pub sl: rte_spinlock_t,
    pub user: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rte_spinlock_recursive_t() {
    const UNINIT: ::std::mem::MaybeUninit<rte_spinlock_recursive_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_spinlock_recursive_t>(),
        12usize,
        concat!("Size of: ", stringify!(rte_spinlock_recursive_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_spinlock_recursive_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_spinlock_recursive_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_spinlock_recursive_t),
            "::",
            stringify!(sl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_spinlock_recursive_t),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_spinlock_recursive_t),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __uintr_frame {
    pub rip: ::std::os::raw::c_ulonglong,
    pub rflags: ::std::os::raw::c_ulonglong,
    pub rsp: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout___uintr_frame() {
    const UNINIT: ::std::mem::MaybeUninit<__uintr_frame> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__uintr_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__uintr_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__uintr_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__uintr_frame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rip) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__uintr_frame),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rflags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__uintr_frame),
            "::",
            stringify!(rflags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__uintr_frame),
            "::",
            stringify!(rsp)
        )
    );
}
pub const _CMPCCX_ENUM__CMPCCX_O: _CMPCCX_ENUM = 0;
pub const _CMPCCX_ENUM__CMPCCX_NO: _CMPCCX_ENUM = 1;
pub const _CMPCCX_ENUM__CMPCCX_B: _CMPCCX_ENUM = 2;
pub const _CMPCCX_ENUM__CMPCCX_NB: _CMPCCX_ENUM = 3;
pub const _CMPCCX_ENUM__CMPCCX_Z: _CMPCCX_ENUM = 4;
pub const _CMPCCX_ENUM__CMPCCX_NZ: _CMPCCX_ENUM = 5;
pub const _CMPCCX_ENUM__CMPCCX_BE: _CMPCCX_ENUM = 6;
pub const _CMPCCX_ENUM__CMPCCX_NBE: _CMPCCX_ENUM = 7;
pub const _CMPCCX_ENUM__CMPCCX_S: _CMPCCX_ENUM = 8;
pub const _CMPCCX_ENUM__CMPCCX_NS: _CMPCCX_ENUM = 9;
pub const _CMPCCX_ENUM__CMPCCX_P: _CMPCCX_ENUM = 10;
pub const _CMPCCX_ENUM__CMPCCX_NP: _CMPCCX_ENUM = 11;
pub const _CMPCCX_ENUM__CMPCCX_L: _CMPCCX_ENUM = 12;
pub const _CMPCCX_ENUM__CMPCCX_NL: _CMPCCX_ENUM = 13;
pub const _CMPCCX_ENUM__CMPCCX_LE: _CMPCCX_ENUM = 14;
pub const _CMPCCX_ENUM__CMPCCX_NLE: _CMPCCX_ENUM = 15;
pub type _CMPCCX_ENUM = ::std::os::raw::c_uint;
pub type __v4df = [f64; 4usize];
pub type __v8sf = [f32; 8usize];
pub type __v4di = [::std::os::raw::c_longlong; 4usize];
pub type __v8si = [::std::os::raw::c_int; 8usize];
pub type __v16hi = [::std::os::raw::c_short; 16usize];
pub type __v32qi = [::std::os::raw::c_char; 32usize];
pub type __v4du = [::std::os::raw::c_ulonglong; 4usize];
pub type __v8su = [::std::os::raw::c_uint; 8usize];
pub type __v16hu = [::std::os::raw::c_ushort; 16usize];
pub type __v32qu = [::std::os::raw::c_uchar; 32usize];
pub type __v32qs = [::std::os::raw::c_schar; 32usize];
pub type __m256 = [f32; 8usize];
pub type __m256d = [f64; 4usize];
pub type __m256i = [::std::os::raw::c_longlong; 4usize];
pub type __m256_u = [f32; 8usize];
pub type __m256d_u = [f64; 4usize];
pub type __m256i_u = [::std::os::raw::c_longlong; 4usize];
pub type __v16hf = [__BindgenFloat16; 16usize];
pub type __m256h = [__BindgenFloat16; 16usize];
pub type __m256h_u = [__BindgenFloat16; 16usize];
pub type __v16bf = [u8; 32usize];
pub type __m256bh = [u8; 32usize];
pub type __v64qi = [::std::os::raw::c_char; 64usize];
pub type __v32hi = [::std::os::raw::c_short; 32usize];
pub type __v8df = [f64; 8usize];
pub type __v16sf = [f32; 16usize];
pub type __v8di = [::std::os::raw::c_longlong; 8usize];
pub type __v16si = [::std::os::raw::c_int; 16usize];
pub type __v64qu = [::std::os::raw::c_uchar; 64usize];
pub type __v32hu = [::std::os::raw::c_ushort; 32usize];
pub type __v8du = [::std::os::raw::c_ulonglong; 8usize];
pub type __v16su = [::std::os::raw::c_uint; 16usize];
pub type __v64qs = [::std::os::raw::c_schar; 64usize];
pub type __m512 = [f32; 16usize];
pub type __m512d = [f64; 8usize];
pub type __m512i = [::std::os::raw::c_longlong; 8usize];
pub type __m512_u = [f32; 16usize];
pub type __m512d_u = [f64; 8usize];
pub type __m512i_u = [::std::os::raw::c_longlong; 8usize];
pub type __mmask8 = ::std::os::raw::c_uchar;
pub type __mmask16 = ::std::os::raw::c_ushort;
pub const _MM_CMPINT_ENUM__MM_CMPINT_EQ: _MM_CMPINT_ENUM = 0;
pub const _MM_CMPINT_ENUM__MM_CMPINT_LT: _MM_CMPINT_ENUM = 1;
pub const _MM_CMPINT_ENUM__MM_CMPINT_LE: _MM_CMPINT_ENUM = 2;
pub const _MM_CMPINT_ENUM__MM_CMPINT_UNUSED: _MM_CMPINT_ENUM = 3;
pub const _MM_CMPINT_ENUM__MM_CMPINT_NE: _MM_CMPINT_ENUM = 4;
pub const _MM_CMPINT_ENUM__MM_CMPINT_NLT: _MM_CMPINT_ENUM = 5;
pub const _MM_CMPINT_ENUM__MM_CMPINT_NLE: _MM_CMPINT_ENUM = 6;
pub type _MM_CMPINT_ENUM = ::std::os::raw::c_uint;
pub const _MM_PERM_ENUM__MM_PERM_AAAA: _MM_PERM_ENUM = 0;
pub const _MM_PERM_ENUM__MM_PERM_AAAB: _MM_PERM_ENUM = 1;
pub const _MM_PERM_ENUM__MM_PERM_AAAC: _MM_PERM_ENUM = 2;
pub const _MM_PERM_ENUM__MM_PERM_AAAD: _MM_PERM_ENUM = 3;
pub const _MM_PERM_ENUM__MM_PERM_AABA: _MM_PERM_ENUM = 4;
pub const _MM_PERM_ENUM__MM_PERM_AABB: _MM_PERM_ENUM = 5;
pub const _MM_PERM_ENUM__MM_PERM_AABC: _MM_PERM_ENUM = 6;
pub const _MM_PERM_ENUM__MM_PERM_AABD: _MM_PERM_ENUM = 7;
pub const _MM_PERM_ENUM__MM_PERM_AACA: _MM_PERM_ENUM = 8;
pub const _MM_PERM_ENUM__MM_PERM_AACB: _MM_PERM_ENUM = 9;
pub const _MM_PERM_ENUM__MM_PERM_AACC: _MM_PERM_ENUM = 10;
pub const _MM_PERM_ENUM__MM_PERM_AACD: _MM_PERM_ENUM = 11;
pub const _MM_PERM_ENUM__MM_PERM_AADA: _MM_PERM_ENUM = 12;
pub const _MM_PERM_ENUM__MM_PERM_AADB: _MM_PERM_ENUM = 13;
pub const _MM_PERM_ENUM__MM_PERM_AADC: _MM_PERM_ENUM = 14;
pub const _MM_PERM_ENUM__MM_PERM_AADD: _MM_PERM_ENUM = 15;
pub const _MM_PERM_ENUM__MM_PERM_ABAA: _MM_PERM_ENUM = 16;
pub const _MM_PERM_ENUM__MM_PERM_ABAB: _MM_PERM_ENUM = 17;
pub const _MM_PERM_ENUM__MM_PERM_ABAC: _MM_PERM_ENUM = 18;
pub const _MM_PERM_ENUM__MM_PERM_ABAD: _MM_PERM_ENUM = 19;
pub const _MM_PERM_ENUM__MM_PERM_ABBA: _MM_PERM_ENUM = 20;
pub const _MM_PERM_ENUM__MM_PERM_ABBB: _MM_PERM_ENUM = 21;
pub const _MM_PERM_ENUM__MM_PERM_ABBC: _MM_PERM_ENUM = 22;
pub const _MM_PERM_ENUM__MM_PERM_ABBD: _MM_PERM_ENUM = 23;
pub const _MM_PERM_ENUM__MM_PERM_ABCA: _MM_PERM_ENUM = 24;
pub const _MM_PERM_ENUM__MM_PERM_ABCB: _MM_PERM_ENUM = 25;
pub const _MM_PERM_ENUM__MM_PERM_ABCC: _MM_PERM_ENUM = 26;
pub const _MM_PERM_ENUM__MM_PERM_ABCD: _MM_PERM_ENUM = 27;
pub const _MM_PERM_ENUM__MM_PERM_ABDA: _MM_PERM_ENUM = 28;
pub const _MM_PERM_ENUM__MM_PERM_ABDB: _MM_PERM_ENUM = 29;
pub const _MM_PERM_ENUM__MM_PERM_ABDC: _MM_PERM_ENUM = 30;
pub const _MM_PERM_ENUM__MM_PERM_ABDD: _MM_PERM_ENUM = 31;
pub const _MM_PERM_ENUM__MM_PERM_ACAA: _MM_PERM_ENUM = 32;
pub const _MM_PERM_ENUM__MM_PERM_ACAB: _MM_PERM_ENUM = 33;
pub const _MM_PERM_ENUM__MM_PERM_ACAC: _MM_PERM_ENUM = 34;
pub const _MM_PERM_ENUM__MM_PERM_ACAD: _MM_PERM_ENUM = 35;
pub const _MM_PERM_ENUM__MM_PERM_ACBA: _MM_PERM_ENUM = 36;
pub const _MM_PERM_ENUM__MM_PERM_ACBB: _MM_PERM_ENUM = 37;
pub const _MM_PERM_ENUM__MM_PERM_ACBC: _MM_PERM_ENUM = 38;
pub const _MM_PERM_ENUM__MM_PERM_ACBD: _MM_PERM_ENUM = 39;
pub const _MM_PERM_ENUM__MM_PERM_ACCA: _MM_PERM_ENUM = 40;
pub const _MM_PERM_ENUM__MM_PERM_ACCB: _MM_PERM_ENUM = 41;
pub const _MM_PERM_ENUM__MM_PERM_ACCC: _MM_PERM_ENUM = 42;
pub const _MM_PERM_ENUM__MM_PERM_ACCD: _MM_PERM_ENUM = 43;
pub const _MM_PERM_ENUM__MM_PERM_ACDA: _MM_PERM_ENUM = 44;
pub const _MM_PERM_ENUM__MM_PERM_ACDB: _MM_PERM_ENUM = 45;
pub const _MM_PERM_ENUM__MM_PERM_ACDC: _MM_PERM_ENUM = 46;
pub const _MM_PERM_ENUM__MM_PERM_ACDD: _MM_PERM_ENUM = 47;
pub const _MM_PERM_ENUM__MM_PERM_ADAA: _MM_PERM_ENUM = 48;
pub const _MM_PERM_ENUM__MM_PERM_ADAB: _MM_PERM_ENUM = 49;
pub const _MM_PERM_ENUM__MM_PERM_ADAC: _MM_PERM_ENUM = 50;
pub const _MM_PERM_ENUM__MM_PERM_ADAD: _MM_PERM_ENUM = 51;
pub const _MM_PERM_ENUM__MM_PERM_ADBA: _MM_PERM_ENUM = 52;
pub const _MM_PERM_ENUM__MM_PERM_ADBB: _MM_PERM_ENUM = 53;
pub const _MM_PERM_ENUM__MM_PERM_ADBC: _MM_PERM_ENUM = 54;
pub const _MM_PERM_ENUM__MM_PERM_ADBD: _MM_PERM_ENUM = 55;
pub const _MM_PERM_ENUM__MM_PERM_ADCA: _MM_PERM_ENUM = 56;
pub const _MM_PERM_ENUM__MM_PERM_ADCB: _MM_PERM_ENUM = 57;
pub const _MM_PERM_ENUM__MM_PERM_ADCC: _MM_PERM_ENUM = 58;
pub const _MM_PERM_ENUM__MM_PERM_ADCD: _MM_PERM_ENUM = 59;
pub const _MM_PERM_ENUM__MM_PERM_ADDA: _MM_PERM_ENUM = 60;
pub const _MM_PERM_ENUM__MM_PERM_ADDB: _MM_PERM_ENUM = 61;
pub const _MM_PERM_ENUM__MM_PERM_ADDC: _MM_PERM_ENUM = 62;
pub const _MM_PERM_ENUM__MM_PERM_ADDD: _MM_PERM_ENUM = 63;
pub const _MM_PERM_ENUM__MM_PERM_BAAA: _MM_PERM_ENUM = 64;
pub const _MM_PERM_ENUM__MM_PERM_BAAB: _MM_PERM_ENUM = 65;
pub const _MM_PERM_ENUM__MM_PERM_BAAC: _MM_PERM_ENUM = 66;
pub const _MM_PERM_ENUM__MM_PERM_BAAD: _MM_PERM_ENUM = 67;
pub const _MM_PERM_ENUM__MM_PERM_BABA: _MM_PERM_ENUM = 68;
pub const _MM_PERM_ENUM__MM_PERM_BABB: _MM_PERM_ENUM = 69;
pub const _MM_PERM_ENUM__MM_PERM_BABC: _MM_PERM_ENUM = 70;
pub const _MM_PERM_ENUM__MM_PERM_BABD: _MM_PERM_ENUM = 71;
pub const _MM_PERM_ENUM__MM_PERM_BACA: _MM_PERM_ENUM = 72;
pub const _MM_PERM_ENUM__MM_PERM_BACB: _MM_PERM_ENUM = 73;
pub const _MM_PERM_ENUM__MM_PERM_BACC: _MM_PERM_ENUM = 74;
pub const _MM_PERM_ENUM__MM_PERM_BACD: _MM_PERM_ENUM = 75;
pub const _MM_PERM_ENUM__MM_PERM_BADA: _MM_PERM_ENUM = 76;
pub const _MM_PERM_ENUM__MM_PERM_BADB: _MM_PERM_ENUM = 77;
pub const _MM_PERM_ENUM__MM_PERM_BADC: _MM_PERM_ENUM = 78;
pub const _MM_PERM_ENUM__MM_PERM_BADD: _MM_PERM_ENUM = 79;
pub const _MM_PERM_ENUM__MM_PERM_BBAA: _MM_PERM_ENUM = 80;
pub const _MM_PERM_ENUM__MM_PERM_BBAB: _MM_PERM_ENUM = 81;
pub const _MM_PERM_ENUM__MM_PERM_BBAC: _MM_PERM_ENUM = 82;
pub const _MM_PERM_ENUM__MM_PERM_BBAD: _MM_PERM_ENUM = 83;
pub const _MM_PERM_ENUM__MM_PERM_BBBA: _MM_PERM_ENUM = 84;
pub const _MM_PERM_ENUM__MM_PERM_BBBB: _MM_PERM_ENUM = 85;
pub const _MM_PERM_ENUM__MM_PERM_BBBC: _MM_PERM_ENUM = 86;
pub const _MM_PERM_ENUM__MM_PERM_BBBD: _MM_PERM_ENUM = 87;
pub const _MM_PERM_ENUM__MM_PERM_BBCA: _MM_PERM_ENUM = 88;
pub const _MM_PERM_ENUM__MM_PERM_BBCB: _MM_PERM_ENUM = 89;
pub const _MM_PERM_ENUM__MM_PERM_BBCC: _MM_PERM_ENUM = 90;
pub const _MM_PERM_ENUM__MM_PERM_BBCD: _MM_PERM_ENUM = 91;
pub const _MM_PERM_ENUM__MM_PERM_BBDA: _MM_PERM_ENUM = 92;
pub const _MM_PERM_ENUM__MM_PERM_BBDB: _MM_PERM_ENUM = 93;
pub const _MM_PERM_ENUM__MM_PERM_BBDC: _MM_PERM_ENUM = 94;
pub const _MM_PERM_ENUM__MM_PERM_BBDD: _MM_PERM_ENUM = 95;
pub const _MM_PERM_ENUM__MM_PERM_BCAA: _MM_PERM_ENUM = 96;
pub const _MM_PERM_ENUM__MM_PERM_BCAB: _MM_PERM_ENUM = 97;
pub const _MM_PERM_ENUM__MM_PERM_BCAC: _MM_PERM_ENUM = 98;
pub const _MM_PERM_ENUM__MM_PERM_BCAD: _MM_PERM_ENUM = 99;
pub const _MM_PERM_ENUM__MM_PERM_BCBA: _MM_PERM_ENUM = 100;
pub const _MM_PERM_ENUM__MM_PERM_BCBB: _MM_PERM_ENUM = 101;
pub const _MM_PERM_ENUM__MM_PERM_BCBC: _MM_PERM_ENUM = 102;
pub const _MM_PERM_ENUM__MM_PERM_BCBD: _MM_PERM_ENUM = 103;
pub const _MM_PERM_ENUM__MM_PERM_BCCA: _MM_PERM_ENUM = 104;
pub const _MM_PERM_ENUM__MM_PERM_BCCB: _MM_PERM_ENUM = 105;
pub const _MM_PERM_ENUM__MM_PERM_BCCC: _MM_PERM_ENUM = 106;
pub const _MM_PERM_ENUM__MM_PERM_BCCD: _MM_PERM_ENUM = 107;
pub const _MM_PERM_ENUM__MM_PERM_BCDA: _MM_PERM_ENUM = 108;
pub const _MM_PERM_ENUM__MM_PERM_BCDB: _MM_PERM_ENUM = 109;
pub const _MM_PERM_ENUM__MM_PERM_BCDC: _MM_PERM_ENUM = 110;
pub const _MM_PERM_ENUM__MM_PERM_BCDD: _MM_PERM_ENUM = 111;
pub const _MM_PERM_ENUM__MM_PERM_BDAA: _MM_PERM_ENUM = 112;
pub const _MM_PERM_ENUM__MM_PERM_BDAB: _MM_PERM_ENUM = 113;
pub const _MM_PERM_ENUM__MM_PERM_BDAC: _MM_PERM_ENUM = 114;
pub const _MM_PERM_ENUM__MM_PERM_BDAD: _MM_PERM_ENUM = 115;
pub const _MM_PERM_ENUM__MM_PERM_BDBA: _MM_PERM_ENUM = 116;
pub const _MM_PERM_ENUM__MM_PERM_BDBB: _MM_PERM_ENUM = 117;
pub const _MM_PERM_ENUM__MM_PERM_BDBC: _MM_PERM_ENUM = 118;
pub const _MM_PERM_ENUM__MM_PERM_BDBD: _MM_PERM_ENUM = 119;
pub const _MM_PERM_ENUM__MM_PERM_BDCA: _MM_PERM_ENUM = 120;
pub const _MM_PERM_ENUM__MM_PERM_BDCB: _MM_PERM_ENUM = 121;
pub const _MM_PERM_ENUM__MM_PERM_BDCC: _MM_PERM_ENUM = 122;
pub const _MM_PERM_ENUM__MM_PERM_BDCD: _MM_PERM_ENUM = 123;
pub const _MM_PERM_ENUM__MM_PERM_BDDA: _MM_PERM_ENUM = 124;
pub const _MM_PERM_ENUM__MM_PERM_BDDB: _MM_PERM_ENUM = 125;
pub const _MM_PERM_ENUM__MM_PERM_BDDC: _MM_PERM_ENUM = 126;
pub const _MM_PERM_ENUM__MM_PERM_BDDD: _MM_PERM_ENUM = 127;
pub const _MM_PERM_ENUM__MM_PERM_CAAA: _MM_PERM_ENUM = 128;
pub const _MM_PERM_ENUM__MM_PERM_CAAB: _MM_PERM_ENUM = 129;
pub const _MM_PERM_ENUM__MM_PERM_CAAC: _MM_PERM_ENUM = 130;
pub const _MM_PERM_ENUM__MM_PERM_CAAD: _MM_PERM_ENUM = 131;
pub const _MM_PERM_ENUM__MM_PERM_CABA: _MM_PERM_ENUM = 132;
pub const _MM_PERM_ENUM__MM_PERM_CABB: _MM_PERM_ENUM = 133;
pub const _MM_PERM_ENUM__MM_PERM_CABC: _MM_PERM_ENUM = 134;
pub const _MM_PERM_ENUM__MM_PERM_CABD: _MM_PERM_ENUM = 135;
pub const _MM_PERM_ENUM__MM_PERM_CACA: _MM_PERM_ENUM = 136;
pub const _MM_PERM_ENUM__MM_PERM_CACB: _MM_PERM_ENUM = 137;
pub const _MM_PERM_ENUM__MM_PERM_CACC: _MM_PERM_ENUM = 138;
pub const _MM_PERM_ENUM__MM_PERM_CACD: _MM_PERM_ENUM = 139;
pub const _MM_PERM_ENUM__MM_PERM_CADA: _MM_PERM_ENUM = 140;
pub const _MM_PERM_ENUM__MM_PERM_CADB: _MM_PERM_ENUM = 141;
pub const _MM_PERM_ENUM__MM_PERM_CADC: _MM_PERM_ENUM = 142;
pub const _MM_PERM_ENUM__MM_PERM_CADD: _MM_PERM_ENUM = 143;
pub const _MM_PERM_ENUM__MM_PERM_CBAA: _MM_PERM_ENUM = 144;
pub const _MM_PERM_ENUM__MM_PERM_CBAB: _MM_PERM_ENUM = 145;
pub const _MM_PERM_ENUM__MM_PERM_CBAC: _MM_PERM_ENUM = 146;
pub const _MM_PERM_ENUM__MM_PERM_CBAD: _MM_PERM_ENUM = 147;
pub const _MM_PERM_ENUM__MM_PERM_CBBA: _MM_PERM_ENUM = 148;
pub const _MM_PERM_ENUM__MM_PERM_CBBB: _MM_PERM_ENUM = 149;
pub const _MM_PERM_ENUM__MM_PERM_CBBC: _MM_PERM_ENUM = 150;
pub const _MM_PERM_ENUM__MM_PERM_CBBD: _MM_PERM_ENUM = 151;
pub const _MM_PERM_ENUM__MM_PERM_CBCA: _MM_PERM_ENUM = 152;
pub const _MM_PERM_ENUM__MM_PERM_CBCB: _MM_PERM_ENUM = 153;
pub const _MM_PERM_ENUM__MM_PERM_CBCC: _MM_PERM_ENUM = 154;
pub const _MM_PERM_ENUM__MM_PERM_CBCD: _MM_PERM_ENUM = 155;
pub const _MM_PERM_ENUM__MM_PERM_CBDA: _MM_PERM_ENUM = 156;
pub const _MM_PERM_ENUM__MM_PERM_CBDB: _MM_PERM_ENUM = 157;
pub const _MM_PERM_ENUM__MM_PERM_CBDC: _MM_PERM_ENUM = 158;
pub const _MM_PERM_ENUM__MM_PERM_CBDD: _MM_PERM_ENUM = 159;
pub const _MM_PERM_ENUM__MM_PERM_CCAA: _MM_PERM_ENUM = 160;
pub const _MM_PERM_ENUM__MM_PERM_CCAB: _MM_PERM_ENUM = 161;
pub const _MM_PERM_ENUM__MM_PERM_CCAC: _MM_PERM_ENUM = 162;
pub const _MM_PERM_ENUM__MM_PERM_CCAD: _MM_PERM_ENUM = 163;
pub const _MM_PERM_ENUM__MM_PERM_CCBA: _MM_PERM_ENUM = 164;
pub const _MM_PERM_ENUM__MM_PERM_CCBB: _MM_PERM_ENUM = 165;
pub const _MM_PERM_ENUM__MM_PERM_CCBC: _MM_PERM_ENUM = 166;
pub const _MM_PERM_ENUM__MM_PERM_CCBD: _MM_PERM_ENUM = 167;
pub const _MM_PERM_ENUM__MM_PERM_CCCA: _MM_PERM_ENUM = 168;
pub const _MM_PERM_ENUM__MM_PERM_CCCB: _MM_PERM_ENUM = 169;
pub const _MM_PERM_ENUM__MM_PERM_CCCC: _MM_PERM_ENUM = 170;
pub const _MM_PERM_ENUM__MM_PERM_CCCD: _MM_PERM_ENUM = 171;
pub const _MM_PERM_ENUM__MM_PERM_CCDA: _MM_PERM_ENUM = 172;
pub const _MM_PERM_ENUM__MM_PERM_CCDB: _MM_PERM_ENUM = 173;
pub const _MM_PERM_ENUM__MM_PERM_CCDC: _MM_PERM_ENUM = 174;
pub const _MM_PERM_ENUM__MM_PERM_CCDD: _MM_PERM_ENUM = 175;
pub const _MM_PERM_ENUM__MM_PERM_CDAA: _MM_PERM_ENUM = 176;
pub const _MM_PERM_ENUM__MM_PERM_CDAB: _MM_PERM_ENUM = 177;
pub const _MM_PERM_ENUM__MM_PERM_CDAC: _MM_PERM_ENUM = 178;
pub const _MM_PERM_ENUM__MM_PERM_CDAD: _MM_PERM_ENUM = 179;
pub const _MM_PERM_ENUM__MM_PERM_CDBA: _MM_PERM_ENUM = 180;
pub const _MM_PERM_ENUM__MM_PERM_CDBB: _MM_PERM_ENUM = 181;
pub const _MM_PERM_ENUM__MM_PERM_CDBC: _MM_PERM_ENUM = 182;
pub const _MM_PERM_ENUM__MM_PERM_CDBD: _MM_PERM_ENUM = 183;
pub const _MM_PERM_ENUM__MM_PERM_CDCA: _MM_PERM_ENUM = 184;
pub const _MM_PERM_ENUM__MM_PERM_CDCB: _MM_PERM_ENUM = 185;
pub const _MM_PERM_ENUM__MM_PERM_CDCC: _MM_PERM_ENUM = 186;
pub const _MM_PERM_ENUM__MM_PERM_CDCD: _MM_PERM_ENUM = 187;
pub const _MM_PERM_ENUM__MM_PERM_CDDA: _MM_PERM_ENUM = 188;
pub const _MM_PERM_ENUM__MM_PERM_CDDB: _MM_PERM_ENUM = 189;
pub const _MM_PERM_ENUM__MM_PERM_CDDC: _MM_PERM_ENUM = 190;
pub const _MM_PERM_ENUM__MM_PERM_CDDD: _MM_PERM_ENUM = 191;
pub const _MM_PERM_ENUM__MM_PERM_DAAA: _MM_PERM_ENUM = 192;
pub const _MM_PERM_ENUM__MM_PERM_DAAB: _MM_PERM_ENUM = 193;
pub const _MM_PERM_ENUM__MM_PERM_DAAC: _MM_PERM_ENUM = 194;
pub const _MM_PERM_ENUM__MM_PERM_DAAD: _MM_PERM_ENUM = 195;
pub const _MM_PERM_ENUM__MM_PERM_DABA: _MM_PERM_ENUM = 196;
pub const _MM_PERM_ENUM__MM_PERM_DABB: _MM_PERM_ENUM = 197;
pub const _MM_PERM_ENUM__MM_PERM_DABC: _MM_PERM_ENUM = 198;
pub const _MM_PERM_ENUM__MM_PERM_DABD: _MM_PERM_ENUM = 199;
pub const _MM_PERM_ENUM__MM_PERM_DACA: _MM_PERM_ENUM = 200;
pub const _MM_PERM_ENUM__MM_PERM_DACB: _MM_PERM_ENUM = 201;
pub const _MM_PERM_ENUM__MM_PERM_DACC: _MM_PERM_ENUM = 202;
pub const _MM_PERM_ENUM__MM_PERM_DACD: _MM_PERM_ENUM = 203;
pub const _MM_PERM_ENUM__MM_PERM_DADA: _MM_PERM_ENUM = 204;
pub const _MM_PERM_ENUM__MM_PERM_DADB: _MM_PERM_ENUM = 205;
pub const _MM_PERM_ENUM__MM_PERM_DADC: _MM_PERM_ENUM = 206;
pub const _MM_PERM_ENUM__MM_PERM_DADD: _MM_PERM_ENUM = 207;
pub const _MM_PERM_ENUM__MM_PERM_DBAA: _MM_PERM_ENUM = 208;
pub const _MM_PERM_ENUM__MM_PERM_DBAB: _MM_PERM_ENUM = 209;
pub const _MM_PERM_ENUM__MM_PERM_DBAC: _MM_PERM_ENUM = 210;
pub const _MM_PERM_ENUM__MM_PERM_DBAD: _MM_PERM_ENUM = 211;
pub const _MM_PERM_ENUM__MM_PERM_DBBA: _MM_PERM_ENUM = 212;
pub const _MM_PERM_ENUM__MM_PERM_DBBB: _MM_PERM_ENUM = 213;
pub const _MM_PERM_ENUM__MM_PERM_DBBC: _MM_PERM_ENUM = 214;
pub const _MM_PERM_ENUM__MM_PERM_DBBD: _MM_PERM_ENUM = 215;
pub const _MM_PERM_ENUM__MM_PERM_DBCA: _MM_PERM_ENUM = 216;
pub const _MM_PERM_ENUM__MM_PERM_DBCB: _MM_PERM_ENUM = 217;
pub const _MM_PERM_ENUM__MM_PERM_DBCC: _MM_PERM_ENUM = 218;
pub const _MM_PERM_ENUM__MM_PERM_DBCD: _MM_PERM_ENUM = 219;
pub const _MM_PERM_ENUM__MM_PERM_DBDA: _MM_PERM_ENUM = 220;
pub const _MM_PERM_ENUM__MM_PERM_DBDB: _MM_PERM_ENUM = 221;
pub const _MM_PERM_ENUM__MM_PERM_DBDC: _MM_PERM_ENUM = 222;
pub const _MM_PERM_ENUM__MM_PERM_DBDD: _MM_PERM_ENUM = 223;
pub const _MM_PERM_ENUM__MM_PERM_DCAA: _MM_PERM_ENUM = 224;
pub const _MM_PERM_ENUM__MM_PERM_DCAB: _MM_PERM_ENUM = 225;
pub const _MM_PERM_ENUM__MM_PERM_DCAC: _MM_PERM_ENUM = 226;
pub const _MM_PERM_ENUM__MM_PERM_DCAD: _MM_PERM_ENUM = 227;
pub const _MM_PERM_ENUM__MM_PERM_DCBA: _MM_PERM_ENUM = 228;
pub const _MM_PERM_ENUM__MM_PERM_DCBB: _MM_PERM_ENUM = 229;
pub const _MM_PERM_ENUM__MM_PERM_DCBC: _MM_PERM_ENUM = 230;
pub const _MM_PERM_ENUM__MM_PERM_DCBD: _MM_PERM_ENUM = 231;
pub const _MM_PERM_ENUM__MM_PERM_DCCA: _MM_PERM_ENUM = 232;
pub const _MM_PERM_ENUM__MM_PERM_DCCB: _MM_PERM_ENUM = 233;
pub const _MM_PERM_ENUM__MM_PERM_DCCC: _MM_PERM_ENUM = 234;
pub const _MM_PERM_ENUM__MM_PERM_DCCD: _MM_PERM_ENUM = 235;
pub const _MM_PERM_ENUM__MM_PERM_DCDA: _MM_PERM_ENUM = 236;
pub const _MM_PERM_ENUM__MM_PERM_DCDB: _MM_PERM_ENUM = 237;
pub const _MM_PERM_ENUM__MM_PERM_DCDC: _MM_PERM_ENUM = 238;
pub const _MM_PERM_ENUM__MM_PERM_DCDD: _MM_PERM_ENUM = 239;
pub const _MM_PERM_ENUM__MM_PERM_DDAA: _MM_PERM_ENUM = 240;
pub const _MM_PERM_ENUM__MM_PERM_DDAB: _MM_PERM_ENUM = 241;
pub const _MM_PERM_ENUM__MM_PERM_DDAC: _MM_PERM_ENUM = 242;
pub const _MM_PERM_ENUM__MM_PERM_DDAD: _MM_PERM_ENUM = 243;
pub const _MM_PERM_ENUM__MM_PERM_DDBA: _MM_PERM_ENUM = 244;
pub const _MM_PERM_ENUM__MM_PERM_DDBB: _MM_PERM_ENUM = 245;
pub const _MM_PERM_ENUM__MM_PERM_DDBC: _MM_PERM_ENUM = 246;
pub const _MM_PERM_ENUM__MM_PERM_DDBD: _MM_PERM_ENUM = 247;
pub const _MM_PERM_ENUM__MM_PERM_DDCA: _MM_PERM_ENUM = 248;
pub const _MM_PERM_ENUM__MM_PERM_DDCB: _MM_PERM_ENUM = 249;
pub const _MM_PERM_ENUM__MM_PERM_DDCC: _MM_PERM_ENUM = 250;
pub const _MM_PERM_ENUM__MM_PERM_DDCD: _MM_PERM_ENUM = 251;
pub const _MM_PERM_ENUM__MM_PERM_DDDA: _MM_PERM_ENUM = 252;
pub const _MM_PERM_ENUM__MM_PERM_DDDB: _MM_PERM_ENUM = 253;
pub const _MM_PERM_ENUM__MM_PERM_DDDC: _MM_PERM_ENUM = 254;
pub const _MM_PERM_ENUM__MM_PERM_DDDD: _MM_PERM_ENUM = 255;
pub type _MM_PERM_ENUM = ::std::os::raw::c_uint;
pub const _MM_MANTISSA_NORM_ENUM__MM_MANT_NORM_1_2: _MM_MANTISSA_NORM_ENUM = 0;
pub const _MM_MANTISSA_NORM_ENUM__MM_MANT_NORM_p5_2: _MM_MANTISSA_NORM_ENUM = 1;
pub const _MM_MANTISSA_NORM_ENUM__MM_MANT_NORM_p5_1: _MM_MANTISSA_NORM_ENUM = 2;
pub const _MM_MANTISSA_NORM_ENUM__MM_MANT_NORM_p75_1p5: _MM_MANTISSA_NORM_ENUM = 3;
pub type _MM_MANTISSA_NORM_ENUM = ::std::os::raw::c_uint;
pub const _MM_MANTISSA_SIGN_ENUM__MM_MANT_SIGN_src: _MM_MANTISSA_SIGN_ENUM = 0;
pub const _MM_MANTISSA_SIGN_ENUM__MM_MANT_SIGN_zero: _MM_MANTISSA_SIGN_ENUM = 1;
pub const _MM_MANTISSA_SIGN_ENUM__MM_MANT_SIGN_nan: _MM_MANTISSA_SIGN_ENUM = 2;
pub type _MM_MANTISSA_SIGN_ENUM = ::std::os::raw::c_uint;
pub const _MM_TERNLOG_ENUM__MM_TERNLOG_A: _MM_TERNLOG_ENUM = 240;
pub const _MM_TERNLOG_ENUM__MM_TERNLOG_B: _MM_TERNLOG_ENUM = 204;
pub const _MM_TERNLOG_ENUM__MM_TERNLOG_C: _MM_TERNLOG_ENUM = 170;
pub type _MM_TERNLOG_ENUM = ::std::os::raw::c_uint;
pub type __v2hi = [::std::os::raw::c_short; 2usize];
pub type __v4qi = [::std::os::raw::c_char; 4usize];
pub type __v2qi = [::std::os::raw::c_char; 2usize];
pub type __mmask32 = ::std::os::raw::c_uint;
pub type __mmask64 = ::std::os::raw::c_ulonglong;
pub type __v32hf = [__BindgenFloat16; 32usize];
pub type __m512h = [__BindgenFloat16; 32usize];
pub type __m512h_u = [__BindgenFloat16; 32usize];
pub type __v32bf = [u8; 64usize];
pub type __m512bh = [u8; 64usize];
pub type __bfloat16 = u16;
pub type _tile1024i = [::std::os::raw::c_int; 256usize];
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct __tile1024i_str {
    pub row: ::std::os::raw::c_ushort,
    pub col: ::std::os::raw::c_ushort,
    pub __bindgen_padding_0: [u64; 7usize],
    pub tile: _tile1024i,
}
#[test]
fn bindgen_test_layout___tile1024i_str() {
    const UNINIT: ::std::mem::MaybeUninit<__tile1024i_str> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__tile1024i_str>(),
        1088usize,
        concat!("Size of: ", stringify!(__tile1024i_str))
    );
    assert_eq!(
        ::std::mem::align_of::<__tile1024i_str>(),
        64usize,
        concat!("Alignment of ", stringify!(__tile1024i_str))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).row) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tile1024i_str),
            "::",
            stringify!(row)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).col) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__tile1024i_str),
            "::",
            stringify!(col)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tile) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__tile1024i_str),
            "::",
            stringify!(tile)
        )
    );
}
pub type __tile1024i = __tile1024i_str;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE3: rte_cpu_flag_t = 0;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PCLMULQDQ: rte_cpu_flag_t = 1;
pub const rte_cpu_flag_t_RTE_CPUFLAG_DTES64: rte_cpu_flag_t = 2;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MONITOR: rte_cpu_flag_t = 3;
pub const rte_cpu_flag_t_RTE_CPUFLAG_DS_CPL: rte_cpu_flag_t = 4;
pub const rte_cpu_flag_t_RTE_CPUFLAG_VMX: rte_cpu_flag_t = 5;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SMX: rte_cpu_flag_t = 6;
pub const rte_cpu_flag_t_RTE_CPUFLAG_EIST: rte_cpu_flag_t = 7;
pub const rte_cpu_flag_t_RTE_CPUFLAG_TM2: rte_cpu_flag_t = 8;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSSE3: rte_cpu_flag_t = 9;
pub const rte_cpu_flag_t_RTE_CPUFLAG_CNXT_ID: rte_cpu_flag_t = 10;
pub const rte_cpu_flag_t_RTE_CPUFLAG_FMA: rte_cpu_flag_t = 11;
pub const rte_cpu_flag_t_RTE_CPUFLAG_CMPXCHG16B: rte_cpu_flag_t = 12;
pub const rte_cpu_flag_t_RTE_CPUFLAG_XTPR: rte_cpu_flag_t = 13;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PDCM: rte_cpu_flag_t = 14;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PCID: rte_cpu_flag_t = 15;
pub const rte_cpu_flag_t_RTE_CPUFLAG_DCA: rte_cpu_flag_t = 16;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE4_1: rte_cpu_flag_t = 17;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE4_2: rte_cpu_flag_t = 18;
pub const rte_cpu_flag_t_RTE_CPUFLAG_X2APIC: rte_cpu_flag_t = 19;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MOVBE: rte_cpu_flag_t = 20;
pub const rte_cpu_flag_t_RTE_CPUFLAG_POPCNT: rte_cpu_flag_t = 21;
pub const rte_cpu_flag_t_RTE_CPUFLAG_TSC_DEADLINE: rte_cpu_flag_t = 22;
pub const rte_cpu_flag_t_RTE_CPUFLAG_AES: rte_cpu_flag_t = 23;
pub const rte_cpu_flag_t_RTE_CPUFLAG_XSAVE: rte_cpu_flag_t = 24;
pub const rte_cpu_flag_t_RTE_CPUFLAG_OSXSAVE: rte_cpu_flag_t = 25;
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX: rte_cpu_flag_t = 26;
pub const rte_cpu_flag_t_RTE_CPUFLAG_F16C: rte_cpu_flag_t = 27;
pub const rte_cpu_flag_t_RTE_CPUFLAG_RDRAND: rte_cpu_flag_t = 28;
pub const rte_cpu_flag_t_RTE_CPUFLAG_HYPERVISOR: rte_cpu_flag_t = 29;
pub const rte_cpu_flag_t_RTE_CPUFLAG_FPU: rte_cpu_flag_t = 30;
pub const rte_cpu_flag_t_RTE_CPUFLAG_VME: rte_cpu_flag_t = 31;
pub const rte_cpu_flag_t_RTE_CPUFLAG_DE: rte_cpu_flag_t = 32;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PSE: rte_cpu_flag_t = 33;
pub const rte_cpu_flag_t_RTE_CPUFLAG_TSC: rte_cpu_flag_t = 34;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MSR: rte_cpu_flag_t = 35;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PAE: rte_cpu_flag_t = 36;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MCE: rte_cpu_flag_t = 37;
pub const rte_cpu_flag_t_RTE_CPUFLAG_CX8: rte_cpu_flag_t = 38;
pub const rte_cpu_flag_t_RTE_CPUFLAG_APIC: rte_cpu_flag_t = 39;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SEP: rte_cpu_flag_t = 40;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MTRR: rte_cpu_flag_t = 41;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PGE: rte_cpu_flag_t = 42;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MCA: rte_cpu_flag_t = 43;
pub const rte_cpu_flag_t_RTE_CPUFLAG_CMOV: rte_cpu_flag_t = 44;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PAT: rte_cpu_flag_t = 45;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PSE36: rte_cpu_flag_t = 46;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PSN: rte_cpu_flag_t = 47;
pub const rte_cpu_flag_t_RTE_CPUFLAG_CLFSH: rte_cpu_flag_t = 48;
pub const rte_cpu_flag_t_RTE_CPUFLAG_DS: rte_cpu_flag_t = 49;
pub const rte_cpu_flag_t_RTE_CPUFLAG_ACPI: rte_cpu_flag_t = 50;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MMX: rte_cpu_flag_t = 51;
pub const rte_cpu_flag_t_RTE_CPUFLAG_FXSR: rte_cpu_flag_t = 52;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE: rte_cpu_flag_t = 53;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE2: rte_cpu_flag_t = 54;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SS: rte_cpu_flag_t = 55;
pub const rte_cpu_flag_t_RTE_CPUFLAG_HTT: rte_cpu_flag_t = 56;
pub const rte_cpu_flag_t_RTE_CPUFLAG_TM: rte_cpu_flag_t = 57;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PBE: rte_cpu_flag_t = 58;
pub const rte_cpu_flag_t_RTE_CPUFLAG_DIGTEMP: rte_cpu_flag_t = 59;
pub const rte_cpu_flag_t_RTE_CPUFLAG_TRBOBST: rte_cpu_flag_t = 60;
pub const rte_cpu_flag_t_RTE_CPUFLAG_ARAT: rte_cpu_flag_t = 61;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PLN: rte_cpu_flag_t = 62;
pub const rte_cpu_flag_t_RTE_CPUFLAG_ECMD: rte_cpu_flag_t = 63;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PTM: rte_cpu_flag_t = 64;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MPERF_APERF_MSR: rte_cpu_flag_t = 65;
pub const rte_cpu_flag_t_RTE_CPUFLAG_ACNT2: rte_cpu_flag_t = 66;
pub const rte_cpu_flag_t_RTE_CPUFLAG_ENERGY_EFF: rte_cpu_flag_t = 67;
pub const rte_cpu_flag_t_RTE_CPUFLAG_FSGSBASE: rte_cpu_flag_t = 68;
pub const rte_cpu_flag_t_RTE_CPUFLAG_BMI1: rte_cpu_flag_t = 69;
pub const rte_cpu_flag_t_RTE_CPUFLAG_HLE: rte_cpu_flag_t = 70;
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX2: rte_cpu_flag_t = 71;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SMEP: rte_cpu_flag_t = 72;
pub const rte_cpu_flag_t_RTE_CPUFLAG_BMI2: rte_cpu_flag_t = 73;
pub const rte_cpu_flag_t_RTE_CPUFLAG_ERMS: rte_cpu_flag_t = 74;
pub const rte_cpu_flag_t_RTE_CPUFLAG_INVPCID: rte_cpu_flag_t = 75;
pub const rte_cpu_flag_t_RTE_CPUFLAG_RTM: rte_cpu_flag_t = 76;
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512F: rte_cpu_flag_t = 77;
pub const rte_cpu_flag_t_RTE_CPUFLAG_RDSEED: rte_cpu_flag_t = 78;
pub const rte_cpu_flag_t_RTE_CPUFLAG_LAHF_SAHF: rte_cpu_flag_t = 79;
pub const rte_cpu_flag_t_RTE_CPUFLAG_LZCNT: rte_cpu_flag_t = 80;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SYSCALL: rte_cpu_flag_t = 81;
pub const rte_cpu_flag_t_RTE_CPUFLAG_XD: rte_cpu_flag_t = 82;
pub const rte_cpu_flag_t_RTE_CPUFLAG_1GB_PG: rte_cpu_flag_t = 83;
pub const rte_cpu_flag_t_RTE_CPUFLAG_RDTSCP: rte_cpu_flag_t = 84;
pub const rte_cpu_flag_t_RTE_CPUFLAG_EM64T: rte_cpu_flag_t = 85;
pub const rte_cpu_flag_t_RTE_CPUFLAG_INVTSC: rte_cpu_flag_t = 86;
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512DQ: rte_cpu_flag_t = 87;
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512IFMA: rte_cpu_flag_t = 88;
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512CD: rte_cpu_flag_t = 89;
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512BW: rte_cpu_flag_t = 90;
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512VL: rte_cpu_flag_t = 91;
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512VBMI: rte_cpu_flag_t = 92;
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512VBMI2: rte_cpu_flag_t = 93;
pub const rte_cpu_flag_t_RTE_CPUFLAG_GFNI: rte_cpu_flag_t = 94;
pub const rte_cpu_flag_t_RTE_CPUFLAG_VAES: rte_cpu_flag_t = 95;
pub const rte_cpu_flag_t_RTE_CPUFLAG_VPCLMULQDQ: rte_cpu_flag_t = 96;
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512VNNI: rte_cpu_flag_t = 97;
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512BITALG: rte_cpu_flag_t = 98;
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512VPOPCNTDQ: rte_cpu_flag_t = 99;
pub const rte_cpu_flag_t_RTE_CPUFLAG_CLDEMOTE: rte_cpu_flag_t = 100;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MOVDIRI: rte_cpu_flag_t = 101;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MOVDIR64B: rte_cpu_flag_t = 102;
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512VP2INTERSECT: rte_cpu_flag_t = 103;
pub const rte_cpu_flag_t_RTE_CPUFLAG_WAITPKG: rte_cpu_flag_t = 104;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MONITORX: rte_cpu_flag_t = 105;
pub type rte_cpu_flag_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_cpu_intrinsics {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_rte_cpu_intrinsics() {
    assert_eq!(
        ::std::mem::size_of::<rte_cpu_intrinsics>(),
        4usize,
        concat!("Size of: ", stringify!(rte_cpu_intrinsics))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_cpu_intrinsics>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_cpu_intrinsics))
    );
}
impl rte_cpu_intrinsics {
    #[inline]
    pub fn power_monitor(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_power_monitor(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn power_pause(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_power_pause(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn power_monitor_multi(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_power_monitor_multi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        power_monitor: u32,
        power_pause: u32,
        power_monitor_multi: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let power_monitor: u32 = unsafe { ::std::mem::transmute(power_monitor) };
            power_monitor as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let power_pause: u32 = unsafe { ::std::mem::transmute(power_pause) };
            power_pause as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let power_monitor_multi: u32 = unsafe { ::std::mem::transmute(power_monitor_multi) };
            power_monitor_multi as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn rte_cpu_get_intrinsics_support(intrinsics: *mut rte_cpu_intrinsics);
}
extern "C" {
    pub fn rte_cpu_get_flag_name(feature: rte_cpu_flag_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rte_cpu_get_flag_enabled(feature: rte_cpu_flag_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_cpu_is_supported() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_cpu_getauxval(type_: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn rte_cpu_strcmp_auxval(
        type_: ::std::os::raw::c_ulong,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_openlog_stream(f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_get_stream() -> *mut FILE;
}
extern "C" {
    pub fn rte_log_set_global_level(level: u32);
}
extern "C" {
    pub fn rte_log_get_global_level() -> u32;
}
extern "C" {
    pub fn rte_log_get_level(logtype: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_can_log(logtype: u32, loglevel: u32) -> bool;
}
extern "C" {
    pub fn rte_log_set_level_pattern(
        pattern: *const ::std::os::raw::c_char,
        level: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_set_level_regexp(
        regex: *const ::std::os::raw::c_char,
        level: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_set_level(logtype: u32, level: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_cur_msg_loglevel() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_cur_msg_logtype() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_register(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_register_type_and_pick_level(
        name: *const ::std::os::raw::c_char,
        level_def: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_list_types(out: *mut FILE, prefix: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rte_log_dump(f: *mut FILE);
}
extern "C" {
    pub fn rte_log(
        level: u32,
        logtype: u32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_vlog(
        level: u32,
        logtype: u32,
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_dump_stack();
}
extern "C" {
    pub fn __rte_panic(
        funcname: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> !;
}
pub const timer_source_EAL_TIMER_TSC: timer_source = 0;
pub const timer_source_EAL_TIMER_HPET: timer_source = 1;
pub type timer_source = ::std::os::raw::c_uint;
extern "C" {
    pub static mut eal_timer_source: timer_source;
}
extern "C" {
    pub fn rte_get_tsc_hz() -> u64;
}
extern "C" {
    pub static mut rte_delay_us:
        ::std::option::Option<unsafe extern "C" fn(us: ::std::os::raw::c_uint)>;
}
extern "C" {
    pub fn rte_delay_us_block(us: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rte_delay_us_sleep(us: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rte_delay_us_callback_register(
        userfunc: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_uint)>,
    );
}
extern "C" {
    pub static mut rte_rtm_supported: u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_rwlock_t {
    pub cnt: i32,
}
#[test]
fn bindgen_test_layout_rte_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<rte_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_rwlock_t>(),
        4usize,
        concat!("Size of: ", stringify!(rte_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_rwlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cnt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_rwlock_t),
            "::",
            stringify!(cnt)
        )
    );
}
extern "C" {
    pub fn rte_mcfg_mem_get_lock() -> *mut rte_rwlock_t;
}
extern "C" {
    pub fn rte_mcfg_tailq_get_lock() -> *mut rte_rwlock_t;
}
extern "C" {
    pub fn rte_mcfg_mempool_get_lock() -> *mut rte_rwlock_t;
}
extern "C" {
    pub fn rte_mcfg_timer_get_lock() -> *mut rte_spinlock_t;
}
extern "C" {
    pub fn rte_mcfg_ethdev_get_lock() -> *mut rte_spinlock_t;
}
extern "C" {
    pub fn rte_mcfg_mem_read_lock();
}
extern "C" {
    pub fn rte_mcfg_mem_read_unlock();
}
extern "C" {
    pub fn rte_mcfg_mem_write_lock();
}
extern "C" {
    pub fn rte_mcfg_mem_write_unlock();
}
extern "C" {
    pub fn rte_mcfg_tailq_read_lock();
}
extern "C" {
    pub fn rte_mcfg_tailq_read_unlock();
}
extern "C" {
    pub fn rte_mcfg_tailq_write_lock();
}
extern "C" {
    pub fn rte_mcfg_tailq_write_unlock();
}
extern "C" {
    pub fn rte_mcfg_mempool_read_lock();
}
extern "C" {
    pub fn rte_mcfg_mempool_read_unlock();
}
extern "C" {
    pub fn rte_mcfg_mempool_write_lock();
}
extern "C" {
    pub fn rte_mcfg_mempool_write_unlock();
}
extern "C" {
    pub fn rte_mcfg_timer_lock();
}
extern "C" {
    pub fn rte_mcfg_timer_unlock();
}
extern "C" {
    pub fn rte_mcfg_get_single_file_segments() -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_fbarray {
    pub name: [::std::os::raw::c_char; 64usize],
    pub count: ::std::os::raw::c_uint,
    pub len: ::std::os::raw::c_uint,
    pub elt_sz: ::std::os::raw::c_uint,
    pub data: *mut ::std::os::raw::c_void,
    pub rwlock: rte_rwlock_t,
}
#[test]
fn bindgen_test_layout_rte_fbarray() {
    const UNINIT: ::std::mem::MaybeUninit<rte_fbarray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_fbarray>(),
        96usize,
        concat!("Size of: ", stringify!(rte_fbarray))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_fbarray>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_fbarray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fbarray),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fbarray),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fbarray),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elt_sz) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fbarray),
            "::",
            stringify!(elt_sz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fbarray),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rwlock) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fbarray),
            "::",
            stringify!(rwlock)
        )
    );
}
extern "C" {
    pub fn rte_fbarray_init(
        arr: *mut rte_fbarray,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_uint,
        elt_sz: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_attach(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_destroy(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_detach(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_get(
        arr: *const rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rte_fbarray_find_idx(
        arr: *const rte_fbarray,
        elt: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_set_used(
        arr: *mut rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_set_free(
        arr: *mut rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_is_used(
        arr: *mut rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_next_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_next_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_next_n_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_next_n_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_contig_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_contig_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_prev_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_prev_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_prev_n_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_prev_n_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_rev_contig_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_rev_contig_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_biggest_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_biggest_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_rev_biggest_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_rev_biggest_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_dump_metadata(arr: *mut rte_fbarray, f: *mut FILE);
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_memseg {
    pub iova: rte_iova_t,
    pub __bindgen_anon_1: rte_memseg__bindgen_ty_1,
    pub len: usize,
    pub hugepage_sz: u64,
    pub socket_id: i32,
    pub nchannel: u32,
    pub nrank: u32,
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memseg__bindgen_ty_1 {
    pub addr: *mut ::std::os::raw::c_void,
    pub addr_64: u64,
}
#[test]
fn bindgen_test_layout_rte_memseg__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_memseg__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_memseg__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_memseg__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memseg__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memseg__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg__bindgen_ty_1),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr_64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg__bindgen_ty_1),
            "::",
            stringify!(addr_64)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_memseg() {
    const UNINIT: ::std::mem::MaybeUninit<rte_memseg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_memseg>(),
        48usize,
        concat!("Size of: ", stringify!(rte_memseg))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memseg>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_memseg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iova) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(iova)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hugepage_sz) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(hugepage_sz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).socket_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nchannel) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(nchannel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nrank) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(nrank)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_memseg_list {
    pub __bindgen_anon_1: rte_memseg_list__bindgen_ty_1,
    pub page_sz: u64,
    pub socket_id: ::std::os::raw::c_int,
    pub version: u32,
    pub len: usize,
    pub external: ::std::os::raw::c_uint,
    pub heap: ::std::os::raw::c_uint,
    pub memseg_arr: rte_fbarray,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memseg_list__bindgen_ty_1 {
    pub base_va: *mut ::std::os::raw::c_void,
    pub addr_64: u64,
}
#[test]
fn bindgen_test_layout_rte_memseg_list__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_memseg_list__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_memseg_list__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_memseg_list__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memseg_list__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memseg_list__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_va) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list__bindgen_ty_1),
            "::",
            stringify!(base_va)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr_64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list__bindgen_ty_1),
            "::",
            stringify!(addr_64)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_memseg_list() {
    const UNINIT: ::std::mem::MaybeUninit<rte_memseg_list> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_memseg_list>(),
        136usize,
        concat!("Size of: ", stringify!(rte_memseg_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memseg_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memseg_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).page_sz) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(page_sz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).socket_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).external) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(external)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heap) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(heap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memseg_arr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(memseg_arr)
        )
    );
}
extern "C" {
    pub fn rte_mem_lock_page(virt: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mem_virt2phy(virt: *const ::std::os::raw::c_void) -> phys_addr_t;
}
extern "C" {
    pub fn rte_mem_virt2iova(virt: *const ::std::os::raw::c_void) -> rte_iova_t;
}
extern "C" {
    pub fn rte_mem_iova2virt(iova: rte_iova_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rte_mem_virt2memseg(
        virt: *const ::std::os::raw::c_void,
        msl: *const rte_memseg_list,
    ) -> *mut rte_memseg;
}
extern "C" {
    pub fn rte_mem_virt2memseg_list(virt: *const ::std::os::raw::c_void) -> *mut rte_memseg_list;
}
pub type rte_memseg_walk_t = ::std::option::Option<
    unsafe extern "C" fn(
        msl: *const rte_memseg_list,
        ms: *const rte_memseg,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_memseg_contig_walk_t = ::std::option::Option<
    unsafe extern "C" fn(
        msl: *const rte_memseg_list,
        ms: *const rte_memseg,
        len: usize,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_memseg_list_walk_t = ::std::option::Option<
    unsafe extern "C" fn(
        msl: *const rte_memseg_list,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rte_memseg_walk(
        func: rte_memseg_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_contig_walk(
        func: rte_memseg_contig_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_list_walk(
        func: rte_memseg_list_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_walk_thread_unsafe(
        func: rte_memseg_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_contig_walk_thread_unsafe(
        func: rte_memseg_contig_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_list_walk_thread_unsafe(
        func: rte_memseg_list_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_get_fd(ms: *const rte_memseg) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_get_fd_thread_unsafe(ms: *const rte_memseg) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_get_fd_offset(
        ms: *const rte_memseg,
        offset: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_get_fd_offset_thread_unsafe(
        ms: *const rte_memseg,
        offset: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_extmem_register(
        va_addr: *mut ::std::os::raw::c_void,
        len: usize,
        iova_addrs: *mut rte_iova_t,
        n_pages: ::std::os::raw::c_uint,
        page_sz: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_extmem_unregister(
        va_addr: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_extmem_attach(
        va_addr: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_extmem_detach(
        va_addr: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_dump_physmem_layout(f: *mut FILE);
}
extern "C" {
    pub fn rte_eal_get_physmem_size() -> u64;
}
extern "C" {
    pub fn rte_memory_get_nchannel() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_memory_get_nrank() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_mem_check_dma_mask(maskbits: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mem_check_dma_mask_thread_unsafe(maskbits: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mem_set_dma_mask(maskbits: u8);
}
extern "C" {
    pub fn rte_eal_using_phys_addrs() -> ::std::os::raw::c_int;
}
pub const rte_mem_event_RTE_MEM_EVENT_ALLOC: rte_mem_event = 0;
pub const rte_mem_event_RTE_MEM_EVENT_FREE: rte_mem_event = 1;
pub type rte_mem_event = ::std::os::raw::c_uint;
pub type rte_mem_event_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        event_type: rte_mem_event,
        addr: *const ::std::os::raw::c_void,
        len: usize,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn rte_mem_event_callback_register(
        name: *const ::std::os::raw::c_char,
        clb: rte_mem_event_callback_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mem_event_callback_unregister(
        name: *const ::std::os::raw::c_char,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub type rte_mem_alloc_validator_t = ::std::option::Option<
    unsafe extern "C" fn(
        socket_id: ::std::os::raw::c_int,
        cur_limit: usize,
        new_len: usize,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rte_mem_alloc_validator_register(
        name: *const ::std::os::raw::c_char,
        clb: rte_mem_alloc_validator_t,
        socket_id: ::std::os::raw::c_int,
        limit: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mem_alloc_validator_unregister(
        name: *const ::std::os::raw::c_char,
        socket_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_memzone {
    pub name: [::std::os::raw::c_char; 32usize],
    pub iova: rte_iova_t,
    pub __bindgen_anon_1: rte_memzone__bindgen_ty_1,
    pub len: usize,
    pub hugepage_sz: u64,
    pub socket_id: i32,
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memzone__bindgen_ty_1 {
    pub addr: *mut ::std::os::raw::c_void,
    pub addr_64: u64,
}
#[test]
fn bindgen_test_layout_rte_memzone__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_memzone__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_memzone__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_memzone__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memzone__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memzone__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone__bindgen_ty_1),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr_64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone__bindgen_ty_1),
            "::",
            stringify!(addr_64)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_memzone() {
    const UNINIT: ::std::mem::MaybeUninit<rte_memzone> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_memzone>(),
        72usize,
        concat!("Size of: ", stringify!(rte_memzone))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memzone>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_memzone))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iova) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(iova)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hugepage_sz) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(hugepage_sz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).socket_id) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub fn rte_memzone_max_set(max: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memzone_max_get() -> usize;
}
extern "C" {
    pub fn rte_memzone_reserve(
        name: *const ::std::os::raw::c_char,
        len: usize,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *const rte_memzone;
}
extern "C" {
    pub fn rte_memzone_reserve_aligned(
        name: *const ::std::os::raw::c_char,
        len: usize,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
    ) -> *const rte_memzone;
}
extern "C" {
    pub fn rte_memzone_reserve_bounded(
        name: *const ::std::os::raw::c_char,
        len: usize,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
        bound: ::std::os::raw::c_uint,
    ) -> *const rte_memzone;
}
extern "C" {
    pub fn rte_memzone_free(mz: *const rte_memzone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memzone_lookup(name: *const ::std::os::raw::c_char) -> *const rte_memzone;
}
extern "C" {
    pub fn rte_memzone_dump(f: *mut FILE);
}
extern "C" {
    pub fn rte_memzone_walk(
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const rte_memzone, arg: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
pub const rte_ring_queue_behavior_RTE_RING_QUEUE_FIXED: rte_ring_queue_behavior = 0;
pub const rte_ring_queue_behavior_RTE_RING_QUEUE_VARIABLE: rte_ring_queue_behavior = 1;
pub type rte_ring_queue_behavior = ::std::os::raw::c_uint;
pub const rte_ring_sync_type_RTE_RING_SYNC_MT: rte_ring_sync_type = 0;
pub const rte_ring_sync_type_RTE_RING_SYNC_ST: rte_ring_sync_type = 1;
pub const rte_ring_sync_type_RTE_RING_SYNC_MT_RTS: rte_ring_sync_type = 2;
pub const rte_ring_sync_type_RTE_RING_SYNC_MT_HTS: rte_ring_sync_type = 3;
pub type rte_ring_sync_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ring_headtail {
    pub head: u32,
    pub tail: u32,
    pub __bindgen_anon_1: rte_ring_headtail__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_ring_headtail__bindgen_ty_1 {
    pub sync_type: rte_ring_sync_type,
    pub single: u32,
}
#[test]
fn bindgen_test_layout_rte_ring_headtail__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_ring_headtail__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_ring_headtail__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(rte_ring_headtail__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ring_headtail__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_ring_headtail__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sync_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_headtail__bindgen_ty_1),
            "::",
            stringify!(sync_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).single) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_headtail__bindgen_ty_1),
            "::",
            stringify!(single)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_ring_headtail() {
    const UNINIT: ::std::mem::MaybeUninit<rte_ring_headtail> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_ring_headtail>(),
        12usize,
        concat!("Size of: ", stringify!(rte_ring_headtail))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ring_headtail>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_ring_headtail))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_headtail),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_headtail),
            "::",
            stringify!(tail)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __rte_ring_rts_poscnt {
    pub raw: u64,
    pub val: __rte_ring_rts_poscnt__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __rte_ring_rts_poscnt__bindgen_ty_1 {
    pub cnt: u32,
    pub pos: u32,
}
#[test]
fn bindgen_test_layout___rte_ring_rts_poscnt__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__rte_ring_rts_poscnt__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__rte_ring_rts_poscnt__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__rte_ring_rts_poscnt__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__rte_ring_rts_poscnt__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__rte_ring_rts_poscnt__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cnt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__rte_ring_rts_poscnt__bindgen_ty_1),
            "::",
            stringify!(cnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__rte_ring_rts_poscnt__bindgen_ty_1),
            "::",
            stringify!(pos)
        )
    );
}
#[test]
fn bindgen_test_layout___rte_ring_rts_poscnt() {
    const UNINIT: ::std::mem::MaybeUninit<__rte_ring_rts_poscnt> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__rte_ring_rts_poscnt>(),
        8usize,
        concat!("Size of: ", stringify!(__rte_ring_rts_poscnt))
    );
    assert_eq!(
        ::std::mem::align_of::<__rte_ring_rts_poscnt>(),
        8usize,
        concat!("Alignment of ", stringify!(__rte_ring_rts_poscnt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__rte_ring_rts_poscnt),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__rte_ring_rts_poscnt),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ring_rts_headtail {
    pub tail: __rte_ring_rts_poscnt,
    pub sync_type: rte_ring_sync_type,
    pub htd_max: u32,
    pub head: __rte_ring_rts_poscnt,
}
#[test]
fn bindgen_test_layout_rte_ring_rts_headtail() {
    const UNINIT: ::std::mem::MaybeUninit<rte_ring_rts_headtail> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_ring_rts_headtail>(),
        24usize,
        concat!("Size of: ", stringify!(rte_ring_rts_headtail))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ring_rts_headtail>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_ring_rts_headtail))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_rts_headtail),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sync_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_rts_headtail),
            "::",
            stringify!(sync_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).htd_max) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_rts_headtail),
            "::",
            stringify!(htd_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_rts_headtail),
            "::",
            stringify!(head)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __rte_ring_hts_pos {
    pub raw: u64,
    pub pos: __rte_ring_hts_pos__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __rte_ring_hts_pos__bindgen_ty_1 {
    pub head: u32,
    pub tail: u32,
}
#[test]
fn bindgen_test_layout___rte_ring_hts_pos__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__rte_ring_hts_pos__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__rte_ring_hts_pos__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__rte_ring_hts_pos__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__rte_ring_hts_pos__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__rte_ring_hts_pos__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__rte_ring_hts_pos__bindgen_ty_1),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__rte_ring_hts_pos__bindgen_ty_1),
            "::",
            stringify!(tail)
        )
    );
}
#[test]
fn bindgen_test_layout___rte_ring_hts_pos() {
    const UNINIT: ::std::mem::MaybeUninit<__rte_ring_hts_pos> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__rte_ring_hts_pos>(),
        8usize,
        concat!("Size of: ", stringify!(__rte_ring_hts_pos))
    );
    assert_eq!(
        ::std::mem::align_of::<__rte_ring_hts_pos>(),
        8usize,
        concat!("Alignment of ", stringify!(__rte_ring_hts_pos))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__rte_ring_hts_pos),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__rte_ring_hts_pos),
            "::",
            stringify!(pos)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_ring_hts_headtail {
    pub ht: __rte_ring_hts_pos,
    pub sync_type: rte_ring_sync_type,
}
#[test]
fn bindgen_test_layout_rte_ring_hts_headtail() {
    const UNINIT: ::std::mem::MaybeUninit<rte_ring_hts_headtail> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_ring_hts_headtail>(),
        16usize,
        concat!("Size of: ", stringify!(rte_ring_hts_headtail))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ring_hts_headtail>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_ring_hts_headtail))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ht) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_hts_headtail),
            "::",
            stringify!(ht)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sync_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_hts_headtail),
            "::",
            stringify!(sync_type)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_ring {
    pub name: [::std::os::raw::c_char; 29usize],
    pub flags: ::std::os::raw::c_int,
    pub memzone: *const rte_memzone,
    pub size: u32,
    pub mask: u32,
    pub capacity: u32,
    pub __bindgen_padding_0: [u8; 4usize],
    pub cache_guard_0: [::std::os::raw::c_char; 64usize],
    pub __bindgen_anon_1: rte_ring__bindgen_ty_1,
    pub cache_guard_1: [::std::os::raw::c_char; 64usize],
    pub __bindgen_anon_2: rte_ring__bindgen_ty_2,
    pub cache_guard_2: [::std::os::raw::c_char; 64usize],
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub union rte_ring__bindgen_ty_1 {
    pub prod: rte_ring_headtail,
    pub hts_prod: rte_ring_hts_headtail,
    pub rts_prod: rte_ring_rts_headtail,
}
#[test]
fn bindgen_test_layout_rte_ring__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_ring__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_ring__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(rte_ring__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ring__bindgen_ty_1>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_ring__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prod) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring__bindgen_ty_1),
            "::",
            stringify!(prod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hts_prod) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring__bindgen_ty_1),
            "::",
            stringify!(hts_prod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rts_prod) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring__bindgen_ty_1),
            "::",
            stringify!(rts_prod)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub union rte_ring__bindgen_ty_2 {
    pub cons: rte_ring_headtail,
    pub hts_cons: rte_ring_hts_headtail,
    pub rts_cons: rte_ring_rts_headtail,
}
#[test]
fn bindgen_test_layout_rte_ring__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<rte_ring__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_ring__bindgen_ty_2>(),
        64usize,
        concat!("Size of: ", stringify!(rte_ring__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ring__bindgen_ty_2>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_ring__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cons) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring__bindgen_ty_2),
            "::",
            stringify!(cons)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hts_cons) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring__bindgen_ty_2),
            "::",
            stringify!(hts_cons)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rts_cons) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring__bindgen_ty_2),
            "::",
            stringify!(rts_cons)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_ring() {
    const UNINIT: ::std::mem::MaybeUninit<rte_ring> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_ring>(),
        384usize,
        concat!("Size of: ", stringify!(rte_ring))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ring>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_ring))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memzone) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(memzone)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cache_guard_0) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(cache_guard_0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cache_guard_1) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(cache_guard_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cache_guard_2) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(cache_guard_2)
        )
    );
}
extern "C" {
    pub fn rte_ring_get_memsize_elem(
        esize: ::std::os::raw::c_uint,
        count: ::std::os::raw::c_uint,
    ) -> isize;
}
extern "C" {
    pub fn rte_ring_create_elem(
        name: *const ::std::os::raw::c_char,
        esize: ::std::os::raw::c_uint,
        count: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_ring;
}
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_ring_zc_data {
    pub ptr1: *mut ::std::os::raw::c_void,
    pub ptr2: *mut ::std::os::raw::c_void,
    pub n1: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_rte_ring_zc_data() {
    const UNINIT: ::std::mem::MaybeUninit<rte_ring_zc_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_ring_zc_data>(),
        64usize,
        concat!("Size of: ", stringify!(rte_ring_zc_data))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ring_zc_data>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_ring_zc_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_zc_data),
            "::",
            stringify!(ptr1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_zc_data),
            "::",
            stringify!(ptr2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_zc_data),
            "::",
            stringify!(n1)
        )
    );
}
extern "C" {
    pub fn rte_ring_get_memsize(count: ::std::os::raw::c_uint) -> isize;
}
extern "C" {
    pub fn rte_ring_init(
        r: *mut rte_ring,
        name: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_ring_create(
        name: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_ring;
}
extern "C" {
    pub fn rte_ring_free(r: *mut rte_ring);
}
extern "C" {
    pub fn rte_ring_dump(f: *mut FILE, r: *const rte_ring);
}
extern "C" {
    pub fn rte_ring_reset(r: *mut rte_ring);
}
extern "C" {
    pub fn rte_ring_list_dump(f: *mut FILE);
}
extern "C" {
    pub fn rte_ring_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_ring;
}
pub type rte_v64u8_t = [u8; 8usize];
pub type rte_v64u16_t = [u16; 4usize];
pub type rte_v64u32_t = [u32; 2usize];
pub type rte_v128u8_t = [u8; 16usize];
pub type rte_v128u16_t = [u16; 8usize];
pub type rte_v128u32_t = [u32; 4usize];
pub type rte_v128u64_t = [u64; 2usize];
pub type rte_v256u8_t = [u8; 32usize];
pub type rte_v256u16_t = [u16; 16usize];
pub type rte_v256u32_t = [u32; 8usize];
pub type rte_v256u64_t = [u64; 4usize];
pub type rte_v64s8_t = [i8; 8usize];
pub type rte_v64s16_t = [i16; 4usize];
pub type rte_v64s32_t = [i32; 2usize];
pub type rte_v128s8_t = [i8; 16usize];
pub type rte_v128s16_t = [i16; 8usize];
pub type rte_v128s32_t = [i32; 4usize];
pub type rte_v128s64_t = [i64; 2usize];
pub type rte_v256s8_t = [i8; 32usize];
pub type rte_v256s16_t = [i16; 16usize];
pub type rte_v256s32_t = [i32; 8usize];
pub type rte_v256s64_t = [i64; 4usize];
pub const rte_vect_max_simd_RTE_VECT_SIMD_DISABLED: rte_vect_max_simd = 64;
pub const rte_vect_max_simd_RTE_VECT_SIMD_128: rte_vect_max_simd = 128;
pub const rte_vect_max_simd_RTE_VECT_SIMD_256: rte_vect_max_simd = 256;
pub const rte_vect_max_simd_RTE_VECT_SIMD_512: rte_vect_max_simd = 512;
pub const rte_vect_max_simd_RTE_VECT_SIMD_MAX: rte_vect_max_simd = 32768;
pub type rte_vect_max_simd = ::std::os::raw::c_uint;
extern "C" {
    pub fn rte_vect_get_max_simd_bitwidth() -> u16;
}
extern "C" {
    pub fn rte_vect_set_max_simd_bitwidth(bitwidth: u16) -> ::std::os::raw::c_int;
}
pub type xmm_t = __m128i;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union rte_xmm {
    pub x: xmm_t,
    pub u8_: [u8; 16usize],
    pub u16_: [u16; 8usize],
    pub u32_: [u32; 4usize],
    pub u64_: [u64; 2usize],
    pub pd: [f64; 2usize],
}
#[test]
fn bindgen_test_layout_rte_xmm() {
    const UNINIT: ::std::mem::MaybeUninit<rte_xmm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_xmm>(),
        16usize,
        concat!("Size of: ", stringify!(rte_xmm))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_xmm>(),
        16usize,
        concat!("Alignment of ", stringify!(rte_xmm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_xmm),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u8_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_xmm),
            "::",
            stringify!(u8_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u16_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_xmm),
            "::",
            stringify!(u16_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_xmm),
            "::",
            stringify!(u32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_xmm),
            "::",
            stringify!(u64_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_xmm),
            "::",
            stringify!(pd)
        )
    );
}
pub type rte_xmm_t = rte_xmm;
pub const _ISupper: _bindgen_ty_4 = 256;
pub const _ISlower: _bindgen_ty_4 = 512;
pub const _ISalpha: _bindgen_ty_4 = 1024;
pub const _ISdigit: _bindgen_ty_4 = 2048;
pub const _ISxdigit: _bindgen_ty_4 = 4096;
pub const _ISspace: _bindgen_ty_4 = 8192;
pub const _ISprint: _bindgen_ty_4 = 16384;
pub const _ISgraph: _bindgen_ty_4 = 32768;
pub const _ISblank: _bindgen_ty_4 = 1;
pub const _IScntrl: _bindgen_ty_4 = 2;
pub const _ISpunct: _bindgen_ty_4 = 4;
pub const _ISalnum: _bindgen_ty_4 = 8;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
extern "C" {
    pub fn __ctype_b_loc() -> *mut *const ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_strsplit(
        string: *mut ::std::os::raw::c_char,
        stringlen: ::std::os::raw::c_int,
        tokens: *mut *mut ::std::os::raw::c_char,
        maxtokens: ::std::os::raw::c_int,
        delim: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_strscpy(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        dsize: usize,
    ) -> isize;
}
extern "C" {
    pub fn rte_trace_is_enabled() -> bool;
}
pub const rte_trace_mode_RTE_TRACE_MODE_OVERWRITE: rte_trace_mode = 0;
pub const rte_trace_mode_RTE_TRACE_MODE_DISCARD: rte_trace_mode = 1;
pub type rte_trace_mode = ::std::os::raw::c_uint;
extern "C" {
    pub fn rte_trace_mode_set(mode: rte_trace_mode);
}
extern "C" {
    pub fn rte_trace_mode_get() -> rte_trace_mode;
}
extern "C" {
    pub fn rte_trace_pattern(
        pattern: *const ::std::os::raw::c_char,
        enable: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_trace_regexp(
        regex: *const ::std::os::raw::c_char,
        enable: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_trace_save() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_trace_metadata_dump(f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_trace_dump(f: *mut FILE);
}
pub type rte_trace_point_t = u64;
extern "C" {
    pub fn rte_trace_point_enable(tp: *mut rte_trace_point_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_trace_point_disable(tp: *mut rte_trace_point_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_trace_point_is_enabled(tp: *mut rte_trace_point_t) -> bool;
}
extern "C" {
    pub fn rte_trace_point_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_trace_point_t;
}
extern "C" {
    pub fn __rte_trace_mem_per_thread_alloc();
}
extern "C" {
    pub fn __rte_trace_point_emit_field(
        sz: usize,
        field: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __rte_trace_point_register(
        trace: *mut rte_trace_point_t,
        name: *const ::std::os::raw::c_char,
        register_fn: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __rte_mempool_trace_ops_dequeue_bulk: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_ops_dequeue_contig_blocks: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_ops_enqueue_bulk: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_generic_put: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_put_bulk: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_generic_get: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_get_bulk: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_get_contig_blocks: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_default_cache: rte_trace_point_t;
}
extern "C" {
    pub static mut __rte_mempool_trace_cache_flush: rte_trace_point_t;
}
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_cache {
    pub size: u32,
    pub flushthresh: u32,
    pub len: u32,
    pub __bindgen_padding_0: [u64; 6usize],
    pub objs: [*mut ::std::os::raw::c_void; 1024usize],
}
#[test]
fn bindgen_test_layout_rte_mempool_cache() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mempool_cache> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_cache>(),
        8256usize,
        concat!("Size of: ", stringify!(rte_mempool_cache))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_cache>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mempool_cache))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flushthresh) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(flushthresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).objs) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(objs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objsz {
    pub elt_size: u32,
    pub header_size: u32,
    pub trailer_size: u32,
    pub total_size: u32,
}
#[test]
fn bindgen_test_layout_rte_mempool_objsz() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mempool_objsz> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objsz>(),
        16usize,
        concat!("Size of: ", stringify!(rte_mempool_objsz))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objsz>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mempool_objsz))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elt_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objsz),
            "::",
            stringify!(elt_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objsz),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trailer_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objsz),
            "::",
            stringify!(trailer_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objsz),
            "::",
            stringify!(total_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objhdr {
    pub next: rte_mempool_objhdr__bindgen_ty_1,
    pub mp: *mut rte_mempool,
    pub iova: rte_iova_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_objhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mempool_objhdr__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objhdr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool_objhdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objhdr__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mempool_objhdr__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr__bindgen_ty_1),
            "::",
            stringify!(stqe_next)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mempool_objhdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objhdr>(),
        24usize,
        concat!("Size of: ", stringify!(rte_mempool_objhdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objhdr>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_objhdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr),
            "::",
            stringify!(mp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iova) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr),
            "::",
            stringify!(iova)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objhdr_list {
    pub stqh_first: *mut rte_mempool_objhdr,
    pub stqh_last: *mut *mut rte_mempool_objhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr_list() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mempool_objhdr_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objhdr_list>(),
        16usize,
        concat!("Size of: ", stringify!(rte_mempool_objhdr_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objhdr_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_objhdr_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stqh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr_list),
            "::",
            stringify!(stqh_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stqh_last) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr_list),
            "::",
            stringify!(stqh_last)
        )
    );
}
extern "C" {
    pub static mut rte_mempool_logtype: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_memhdr_list {
    pub stqh_first: *mut rte_mempool_memhdr,
    pub stqh_last: *mut *mut rte_mempool_memhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr_list() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mempool_memhdr_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_memhdr_list>(),
        16usize,
        concat!("Size of: ", stringify!(rte_mempool_memhdr_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_memhdr_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_memhdr_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stqh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr_list),
            "::",
            stringify!(stqh_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stqh_last) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr_list),
            "::",
            stringify!(stqh_last)
        )
    );
}
pub type rte_mempool_memchunk_free_cb_t = ::std::option::Option<
    unsafe extern "C" fn(memhdr: *mut rte_mempool_memhdr, opaque: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_memhdr {
    pub next: rte_mempool_memhdr__bindgen_ty_1,
    pub mp: *mut rte_mempool,
    pub addr: *mut ::std::os::raw::c_void,
    pub iova: rte_iova_t,
    pub len: usize,
    pub free_cb: rte_mempool_memchunk_free_cb_t,
    pub opaque: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_memhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_memhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mempool_memhdr__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_memhdr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool_memhdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_memhdr__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mempool_memhdr__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr__bindgen_ty_1),
            "::",
            stringify!(stqe_next)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mempool_memhdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_memhdr>(),
        56usize,
        concat!("Size of: ", stringify!(rte_mempool_memhdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_memhdr>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_memhdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(mp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iova) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(iova)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_cb) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(free_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(opaque)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_info {
    pub contig_block_size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_rte_mempool_info() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mempool_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_info>(),
        64usize,
        concat!("Size of: ", stringify!(rte_mempool_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_info>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mempool_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).contig_block_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_info),
            "::",
            stringify!(contig_block_size)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool {
    pub name: [::std::os::raw::c_char; 26usize],
    pub __bindgen_anon_1: rte_mempool__bindgen_ty_1,
    pub pool_config: *mut ::std::os::raw::c_void,
    pub mz: *const rte_memzone,
    pub flags: ::std::os::raw::c_uint,
    pub socket_id: ::std::os::raw::c_int,
    pub size: u32,
    pub cache_size: u32,
    pub elt_size: u32,
    pub header_size: u32,
    pub trailer_size: u32,
    pub private_data_size: ::std::os::raw::c_uint,
    pub ops_index: i32,
    pub local_cache: *mut rte_mempool_cache,
    pub populated_size: u32,
    pub elt_list: rte_mempool_objhdr_list,
    pub nb_mem_chunks: u32,
    pub mem_list: rte_mempool_memhdr_list,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mempool__bindgen_ty_1 {
    pub pool_data: *mut ::std::os::raw::c_void,
    pub pool_id: u64,
}
#[test]
fn bindgen_test_layout_rte_mempool__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mempool__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mempool__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool__bindgen_ty_1),
            "::",
            stringify!(pool_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool__bindgen_ty_1),
            "::",
            stringify!(pool_id)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mempool() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mempool> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mempool>(),
        192usize,
        concat!("Size of: ", stringify!(rte_mempool))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mempool))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool_config) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(pool_config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mz) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(mz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).socket_id) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cache_size) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(cache_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elt_size) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(elt_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header_size) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trailer_size) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(trailer_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data_size) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(private_data_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ops_index) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(ops_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_cache) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(local_cache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).populated_size) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(populated_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elt_list) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(elt_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_mem_chunks) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(nb_mem_chunks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_list) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(mem_list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objtlr {
    _unused: [u8; 0],
}
extern "C" {
    pub fn rte_mempool_check_cookies(
        mp: *const rte_mempool,
        obj_table_const: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
        free: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn rte_mempool_contig_blocks_check_cookies(
        mp: *const rte_mempool,
        first_obj_table_const: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
        free: ::std::os::raw::c_int,
    );
}
pub type rte_mempool_alloc_t =
    ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool) -> ::std::os::raw::c_int>;
pub type rte_mempool_free_t = ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool)>;
pub type rte_mempool_enqueue_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        obj_table: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_mempool_dequeue_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        obj_table: *mut *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_mempool_dequeue_contig_blocks_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        first_obj_table: *mut *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_mempool_get_count =
    ::std::option::Option<unsafe extern "C" fn(mp: *const rte_mempool) -> ::std::os::raw::c_uint>;
pub type rte_mempool_calc_mem_size_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        min_chunk_size: *mut usize,
        align: *mut usize,
    ) -> isize,
>;
extern "C" {
    pub fn rte_mempool_op_calc_mem_size_helper(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        chunk_reserve: usize,
        min_chunk_size: *mut usize,
        align: *mut usize,
    ) -> isize;
}
extern "C" {
    pub fn rte_mempool_op_calc_mem_size_default(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        min_chunk_size: *mut usize,
        align: *mut usize,
    ) -> isize;
}
pub type rte_mempool_populate_obj_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
    ),
>;
pub type rte_mempool_populate_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: usize,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rte_mempool_op_populate_helper(
        mp: *mut rte_mempool,
        flags: ::std::os::raw::c_uint,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: usize,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mempool_op_populate_default(
        mp: *mut rte_mempool,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: usize,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub type rte_mempool_get_info_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *const rte_mempool,
        info: *mut rte_mempool_info,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_ops {
    pub name: [::std::os::raw::c_char; 32usize],
    pub alloc: rte_mempool_alloc_t,
    pub free: rte_mempool_free_t,
    pub enqueue: rte_mempool_enqueue_t,
    pub dequeue: rte_mempool_dequeue_t,
    pub get_count: rte_mempool_get_count,
    pub calc_mem_size: rte_mempool_calc_mem_size_t,
    pub populate: rte_mempool_populate_t,
    pub get_info: rte_mempool_get_info_t,
    pub dequeue_contig_blocks: rte_mempool_dequeue_contig_blocks_t,
}
#[test]
fn bindgen_test_layout_rte_mempool_ops() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mempool_ops> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_ops>(),
        128usize,
        concat!("Size of: ", stringify!(rte_mempool_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_ops>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mempool_ops))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enqueue) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(enqueue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dequeue) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(dequeue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_count) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(get_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).calc_mem_size) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(calc_mem_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).populate) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(populate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_info) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(get_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dequeue_contig_blocks) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(dequeue_contig_blocks)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_ops_table {
    pub sl: rte_spinlock_t,
    pub num_ops: u32,
    pub __bindgen_padding_0: [u64; 7usize],
    pub ops: [rte_mempool_ops; 16usize],
}
#[test]
fn bindgen_test_layout_rte_mempool_ops_table() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mempool_ops_table> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_ops_table>(),
        2112usize,
        concat!("Size of: ", stringify!(rte_mempool_ops_table))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_ops_table>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mempool_ops_table))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops_table),
            "::",
            stringify!(sl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_ops) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops_table),
            "::",
            stringify!(num_ops)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ops) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops_table),
            "::",
            stringify!(ops)
        )
    );
}
extern "C" {
    pub static mut rte_mempool_ops_table: rte_mempool_ops_table;
}
extern "C" {
    pub fn rte_mempool_ops_alloc(mp: *mut rte_mempool) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mempool_ops_get_count(mp: *const rte_mempool) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_mempool_ops_calc_mem_size(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        min_chunk_size: *mut usize,
        align: *mut usize,
    ) -> isize;
}
extern "C" {
    pub fn rte_mempool_ops_populate(
        mp: *mut rte_mempool,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: usize,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mempool_ops_get_info(
        mp: *const rte_mempool,
        info: *mut rte_mempool_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mempool_ops_free(mp: *mut rte_mempool);
}
extern "C" {
    pub fn rte_mempool_set_ops_byname(
        mp: *mut rte_mempool,
        name: *const ::std::os::raw::c_char,
        pool_config: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mempool_register_ops(ops: *const rte_mempool_ops) -> ::std::os::raw::c_int;
}
pub type rte_mempool_obj_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        obj: *mut ::std::os::raw::c_void,
        obj_idx: ::std::os::raw::c_uint,
    ),
>;
pub type rte_mempool_obj_ctor_t = rte_mempool_obj_cb_t;
pub type rte_mempool_mem_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        memhdr: *mut rte_mempool_memhdr,
        mem_idx: ::std::os::raw::c_uint,
    ),
>;
pub type rte_mempool_ctor_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut rte_mempool, arg2: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn rte_mempool_create(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        elt_size: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        private_data_size: ::std::os::raw::c_uint,
        mp_init: rte_mempool_ctor_t,
        mp_init_arg: *mut ::std::os::raw::c_void,
        obj_init: rte_mempool_obj_cb_t,
        obj_init_arg: *mut ::std::os::raw::c_void,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_mempool;
}
extern "C" {
    pub fn rte_mempool_create_empty(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        elt_size: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        private_data_size: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_mempool;
}
extern "C" {
    pub fn rte_mempool_free(mp: *mut rte_mempool);
}
extern "C" {
    pub fn rte_mempool_populate_iova(
        mp: *mut rte_mempool,
        vaddr: *mut ::std::os::raw::c_char,
        iova: rte_iova_t,
        len: usize,
        free_cb: rte_mempool_memchunk_free_cb_t,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mempool_populate_virt(
        mp: *mut rte_mempool,
        addr: *mut ::std::os::raw::c_char,
        len: usize,
        pg_sz: usize,
        free_cb: rte_mempool_memchunk_free_cb_t,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mempool_populate_default(mp: *mut rte_mempool) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mempool_populate_anon(mp: *mut rte_mempool) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mempool_obj_iter(
        mp: *mut rte_mempool,
        obj_cb: rte_mempool_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> u32;
}
extern "C" {
    pub fn rte_mempool_mem_iter(
        mp: *mut rte_mempool,
        mem_cb: rte_mempool_mem_cb_t,
        mem_cb_arg: *mut ::std::os::raw::c_void,
    ) -> u32;
}
extern "C" {
    pub fn rte_mempool_dump(f: *mut FILE, mp: *mut rte_mempool);
}
extern "C" {
    pub fn rte_mempool_cache_create(
        size: u32,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut rte_mempool_cache;
}
extern "C" {
    pub fn rte_mempool_cache_free(cache: *mut rte_mempool_cache);
}
extern "C" {
    pub fn rte_mempool_avail_count(mp: *const rte_mempool) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_mempool_in_use_count(mp: *const rte_mempool) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_mempool_audit(mp: *mut rte_mempool);
}
extern "C" {
    pub fn rte_mempool_list_dump(f: *mut FILE);
}
extern "C" {
    pub fn rte_mempool_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_mempool;
}
extern "C" {
    pub fn rte_mempool_calc_obj_size(elt_size: u32, flags: u32, sz: *mut rte_mempool_objsz) -> u32;
}
extern "C" {
    pub fn rte_mempool_walk(
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut rte_mempool, arg: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_mem_range_info {
    pub start: *mut ::std::os::raw::c_void,
    pub length: usize,
    pub is_contiguous: bool,
}
#[test]
fn bindgen_test_layout_rte_mempool_mem_range_info() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mempool_mem_range_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_mem_range_info>(),
        24usize,
        concat!("Size of: ", stringify!(rte_mempool_mem_range_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_mem_range_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_mem_range_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_mem_range_info),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_mem_range_info),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_contiguous) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_mem_range_info),
            "::",
            stringify!(is_contiguous)
        )
    );
}
extern "C" {
    pub fn rte_mempool_get_mem_range(
        mp: *const rte_mempool,
        mem_range: *mut rte_mempool_mem_range_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mempool_get_obj_alignment(mp: *const rte_mempool) -> usize;
}
extern "C" {
    pub fn rte_mempool_get_page_size(
        mp: *mut rte_mempool,
        pg_sz: *mut usize,
    ) -> ::std::os::raw::c_int;
}
pub const rte_mempool_event_RTE_MEMPOOL_EVENT_READY: rte_mempool_event = 0;
pub const rte_mempool_event_RTE_MEMPOOL_EVENT_DESTROY: rte_mempool_event = 1;
pub type rte_mempool_event = ::std::os::raw::c_uint;
pub type rte_mempool_event_callback = ::std::option::Option<
    unsafe extern "C" fn(
        event: rte_mempool_event,
        mp: *mut rte_mempool,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn rte_mempool_event_callback_register(
        func: rte_mempool_event_callback,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mempool_event_callback_unregister(
        func: rte_mempool_event_callback,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_get_ptype_l2_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rte_get_ptype_l3_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rte_get_ptype_l4_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rte_get_ptype_tunnel_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rte_get_ptype_inner_l2_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rte_get_ptype_inner_l3_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rte_get_ptype_inner_l4_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rte_get_ptype_name(
        ptype: u32,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf_sched {
    pub queue_id: u32,
    pub traffic_class: u8,
    pub color: u8,
    pub reserved: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf_sched() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mbuf_sched> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf_sched>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mbuf_sched))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf_sched>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mbuf_sched))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queue_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_sched),
            "::",
            stringify!(queue_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).traffic_class) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_sched),
            "::",
            stringify!(traffic_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_sched),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_sched),
            "::",
            stringify!(reserved)
        )
    );
}
pub const RTE_MBUF_L2_LEN_BITS: _bindgen_ty_5 = 7;
pub const RTE_MBUF_L3_LEN_BITS: _bindgen_ty_5 = 9;
pub const RTE_MBUF_L4_LEN_BITS: _bindgen_ty_5 = 8;
pub const RTE_MBUF_TSO_SEGSZ_BITS: _bindgen_ty_5 = 16;
pub const RTE_MBUF_OUTL3_LEN_BITS: _bindgen_ty_5 = 9;
pub const RTE_MBUF_OUTL2_LEN_BITS: _bindgen_ty_5 = 7;
pub const RTE_MBUF_TXOFLD_UNUSED_BITS: _bindgen_ty_5 = 8;
pub const RTE_MBUF_L2_LEN_OFS: _bindgen_ty_5 = 0;
pub const RTE_MBUF_L3_LEN_OFS: _bindgen_ty_5 = 7;
pub const RTE_MBUF_L4_LEN_OFS: _bindgen_ty_5 = 16;
pub const RTE_MBUF_TSO_SEGSZ_OFS: _bindgen_ty_5 = 24;
pub const RTE_MBUF_OUTL3_LEN_OFS: _bindgen_ty_5 = 40;
pub const RTE_MBUF_OUTL2_LEN_OFS: _bindgen_ty_5 = 49;
pub const RTE_MBUF_TXOFLD_UNUSED_OFS: _bindgen_ty_5 = 56;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mbuf {
    pub buf_addr: *mut ::std::os::raw::c_void,
    pub buf_iova: rte_iova_t,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1,
    pub ol_flags: u64,
    pub __bindgen_anon_2: rte_mbuf__bindgen_ty_2,
    pub pool: *mut rte_mempool,
    pub next: *mut rte_mbuf,
    pub __bindgen_anon_3: rte_mbuf__bindgen_ty_3,
    pub shinfo: *mut rte_mbuf_ext_shared_info,
    pub priv_size: u16,
    pub timesync: u16,
    pub dynfield1: [u32; 9usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_1 {
    pub rearm_data: [u64; 1usize],
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_1__bindgen_ty_1 {
    pub data_off: u16,
    pub refcnt: u16,
    pub nb_segs: u16,
    pub port: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mbuf__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_off) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(data_off)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcnt) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nb_segs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(nb_segs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(port)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mbuf__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rearm_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_1),
            "::",
            stringify!(rearm_data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2 {
    pub rx_descriptor_fields1: [*mut ::std::os::raw::c_void; 3usize],
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub pkt_len: u32,
    pub data_len: u16,
    pub vlan_tci: u16,
    pub __bindgen_anon_2: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
    pub vlan_tci_outer: u16,
    pub buf_len: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub packet_type: u32,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_anon_1:
        rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 { pub inner_esp_next_proto : u8 , pub __bindgen_anon_1 : rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , }
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
{
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1(
) {
    assert_eq ! (:: std :: mem :: size_of :: < rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 > () , 1usize , concat ! ("Size of: " , stringify ! (rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)));
    assert_eq ! (:: std :: mem :: align_of :: < rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 > () , 1usize , concat ! ("Alignment of " , stringify ! (rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)));
}
impl rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn inner_l2_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l2_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn inner_l3_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l3_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inner_l2_type: u8,
        inner_l3_type: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let inner_l2_type: u8 = unsafe { ::std::mem::transmute(inner_l2_type) };
            inner_l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let inner_l3_type: u8 = unsafe { ::std::mem::transmute(inner_l3_type) };
            inner_l3_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(
                rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(
                rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inner_esp_next_proto) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(inner_esp_next_proto)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn l2_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l2_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn l3_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l3_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn l4_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_l4_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn tun_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tun_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_type: u8,
        l3_type: u8,
        l4_type: u8,
        tun_type: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let l2_type: u8 = unsafe { ::std::mem::transmute(l2_type) };
            l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let l3_type: u8 = unsafe { ::std::mem::transmute(l3_type) };
            l3_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let l4_type: u8 = unsafe { ::std::mem::transmute(l4_type) };
            l4_type as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let tun_type: u8 = unsafe { ::std::mem::transmute(tun_type) };
            tun_type as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn inner_l4_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l4_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(inner_l4_type: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let inner_l4_type: u8 = unsafe { ::std::mem::transmute(inner_l4_type) };
            inner_l4_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packet_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(packet_type)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    pub hash: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub rss: u32,
    pub fdir: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub sched: rte_mbuf_sched,
    pub txadapter: rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
    pub usr: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 { pub __bindgen_anon_1 : rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , pub hi : u32 , }
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 { pub __bindgen_anon_1 : rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , pub lo : u32 , }
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
{
    pub hash: u16,
    pub id: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1(
) {
    const UNINIT : :: std :: mem :: MaybeUninit < rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 > = :: std :: mem :: MaybeUninit :: uninit () ;
    let ptr = UNINIT.as_ptr();
    assert_eq ! (:: std :: mem :: size_of :: < rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 > () , 4usize , concat ! ("Size of: " , stringify ! (rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)));
    assert_eq ! (:: std :: mem :: align_of :: < rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 > () , 2usize , concat ! ("Alignment of " , stringify ! (rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)));
    assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . hash) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1) , "::" , stringify ! (hash)));
    assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . id) as usize - ptr as usize } , 2usize , concat ! ("Offset of field: " , stringify ! (rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1) , "::" , stringify ! (id)));
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1(
) {
    const UNINIT : :: std :: mem :: MaybeUninit < rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 > = :: std :: mem :: MaybeUninit :: uninit () ;
    let ptr = UNINIT.as_ptr();
    assert_eq ! (:: std :: mem :: size_of :: < rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 > () , 4usize , concat ! ("Size of: " , stringify ! (rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)));
    assert_eq ! (:: std :: mem :: align_of :: < rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 > () , 4usize , concat ! ("Alignment of " , stringify ! (rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)));
    assert_eq ! (unsafe { :: std :: ptr :: addr_of ! ((* ptr) . lo) as usize - ptr as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1) , "::" , stringify ! (lo)));
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(
                rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hi) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(
                rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(hi)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    pub reserved1: u32,
    pub reserved2: u16,
    pub txq: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(
                rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2
            )
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2
            ),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(
                rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2
            ),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).txq) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(
                rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2
            ),
            "::",
            stringify!(txq)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rss) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(rss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fdir) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(fdir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(sched)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).txadapter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(txadapter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(usr)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(hash)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mbuf__bindgen_ty_2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pkt_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(pkt_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(data_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vlan_tci) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(vlan_tci)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vlan_tci_outer) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(vlan_tci_outer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_len) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(buf_len)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mbuf__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_2>(),
        24usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_descriptor_fields1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_2),
            "::",
            stringify!(rx_descriptor_fields1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_3 {
    pub tx_offload: u64,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize]>,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1)
        )
    );
}
impl rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn l2_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn l3_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn l4_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_l4_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn tso_segsz(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_tso_segsz(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn outer_l3_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn outer_l2_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_len: u64,
        l3_len: u64,
        l4_len: u64,
        tso_segsz: u64,
        outer_l3_len: u64,
        outer_l2_len: u64,
    ) -> __BindgenBitfieldUnit<[u8; 7usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let l2_len: u64 = unsafe { ::std::mem::transmute(l2_len) };
            l2_len as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let l3_len: u64 = unsafe { ::std::mem::transmute(l3_len) };
            l3_len as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let l4_len: u64 = unsafe { ::std::mem::transmute(l4_len) };
            l4_len as u64
        });
        __bindgen_bitfield_unit.set(24usize, 16u8, {
            let tso_segsz: u64 = unsafe { ::std::mem::transmute(tso_segsz) };
            tso_segsz as u64
        });
        __bindgen_bitfield_unit.set(40usize, 9u8, {
            let outer_l3_len: u64 = unsafe { ::std::mem::transmute(outer_l3_len) };
            outer_l3_len as u64
        });
        __bindgen_bitfield_unit.set(49usize, 7u8, {
            let outer_l2_len: u64 = unsafe { ::std::mem::transmute(outer_l2_len) };
            outer_l2_len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mbuf__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_offload) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf__bindgen_ty_3),
            "::",
            stringify!(tx_offload)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mbuf() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mbuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf>(),
        128usize,
        concat!("Size of: ", stringify!(rte_mbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mbuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(buf_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_iova) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(buf_iova)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ol_flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(ol_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shinfo) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(shinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_size) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(priv_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timesync) as usize - ptr as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(timesync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dynfield1) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf),
            "::",
            stringify!(dynfield1)
        )
    );
}
pub type rte_mbuf_extbuf_free_callback_t = ::std::option::Option<
    unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, opaque: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf_ext_shared_info {
    pub free_cb: rte_mbuf_extbuf_free_callback_t,
    pub fcb_opaque: *mut ::std::os::raw::c_void,
    pub refcnt: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf_ext_shared_info() {
    const UNINIT: ::std::mem::MaybeUninit<rte_mbuf_ext_shared_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf_ext_shared_info>(),
        24usize,
        concat!("Size of: ", stringify!(rte_mbuf_ext_shared_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf_ext_shared_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mbuf_ext_shared_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_cb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_ext_shared_info),
            "::",
            stringify!(free_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fcb_opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_ext_shared_info),
            "::",
            stringify!(fcb_opaque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcnt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mbuf_ext_shared_info),
            "::",
            stringify!(refcnt)
        )
    );
}
extern "C" {
    #[doc = " Get the name of a RX offload flag\n\n @param mask\n   The mask describing the flag.\n @return\n   The name of this flag, or NULL if it's not a valid RX flag."]
    pub fn rte_get_rx_ol_flag_name(mask: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Dump the list of RX offload flags in a buffer\n\n @param mask\n   The mask describing the RX flags.\n @param buf\n   The output buffer.\n @param buflen\n   The length of the buffer.\n @return\n   0 on success, (-1) on error."]
    pub fn rte_get_rx_ol_flag_list(
        mask: u64,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the name of a TX offload flag\n\n @param mask\n   The mask describing the flag. Usually only one bit must be set.\n   Several bits can be given if they belong to the same mask.\n   Ex: RTE_MBUF_F_TX_L4_MASK.\n @return\n   The name of this flag, or NULL if it's not a valid TX flag."]
    pub fn rte_get_tx_ol_flag_name(mask: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Dump the list of TX offload flags in a buffer\n\n @param mask\n   The mask describing the TX flags.\n @param buf\n   The output buffer.\n @param buflen\n   The length of the buffer.\n @return\n   0 on success, (-1) on error."]
    pub fn rte_get_tx_ol_flag_list(
        mask: u64,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Prefetch the first part of the mbuf\n\n The first 64 bytes of the mbuf corresponds to fields that are used early\n in the receive path. If the cache line of the architecture is higher than\n 64B, the second part will also be prefetched.\n\n @param m\n   The pointer to the mbuf."]
    pub fn rte_mbuf_prefetch_part1(m: *mut rte_mbuf);
}
extern "C" {
    #[doc = " Prefetch the second part of the mbuf\n\n The next 64 bytes of the mbuf corresponds to fields that are used in the\n transmit path. If the cache line of the architecture is higher than 64B,\n this function does nothing as it is expected that the full mbuf is\n already in cache.\n\n @param m\n   The pointer to the mbuf."]
    pub fn rte_mbuf_prefetch_part2(m: *mut rte_mbuf);
}
extern "C" {
    #[doc = " Get the application private size of mbufs stored in a pktmbuf_pool\n\n The private size of mbuf is a zone located between the rte_mbuf\n structure and the data buffer where an application can store data\n associated to a packet.\n\n @param mp\n   The packet mbuf pool.\n @return\n   The private size of mbufs stored in this mempool."]
    pub fn rte_pktmbuf_priv_size(mp: *mut rte_mempool) -> u16;
}
extern "C" {
    #[doc = " Get the IOVA address of the mbuf data buffer.\n\n @param m\n   The pointer to the mbuf.\n @return\n   The IOVA address of the mbuf."]
    pub fn rte_mbuf_iova_get(m: *const rte_mbuf) -> rte_iova_t;
}
extern "C" {
    #[doc = " Set the IOVA address of the mbuf data buffer.\n\n @param m\n   The pointer to the mbuf.\n @param iova\n   Value to set as IOVA address of the mbuf."]
    pub fn rte_mbuf_iova_set(m: *mut rte_mbuf, iova: rte_iova_t);
}
extern "C" {
    #[doc = " Return the IO address of the beginning of the mbuf data\n\n @param mb\n   The pointer to the mbuf.\n @return\n   The IO address of the beginning of the mbuf data"]
    pub fn rte_mbuf_data_iova(mb: *const rte_mbuf) -> rte_iova_t;
}
extern "C" {
    #[doc = " Return the default IO address of the beginning of the mbuf data\n\n This function is used by drivers in their receive function, as it\n returns the location where data should be written by the NIC, taking\n the default headroom in account.\n\n @param mb\n   The pointer to the mbuf.\n @return\n   The IO address of the beginning of the mbuf data"]
    pub fn rte_mbuf_data_iova_default(mb: *const rte_mbuf) -> rte_iova_t;
}
extern "C" {
    #[doc = " Return the mbuf owning the data buffer address of an indirect mbuf.\n\n @param mi\n   The pointer to the indirect mbuf.\n @return\n   The address of the direct mbuf corresponding to buffer_addr."]
    pub fn rte_mbuf_from_indirect(mi: *mut rte_mbuf) -> *mut rte_mbuf;
}
extern "C" {
    #[doc = " Return address of buffer embedded in the given mbuf.\n\n The return value shall be same as mb->buf_addr if the mbuf is already\n initialized and direct. However, this API is useful if mempool of the\n mbuf is already known because it doesn't need to access mbuf contents in\n order to get the mempool pointer.\n\n @param mb\n   The pointer to the mbuf.\n @param mp\n   The pointer to the mempool of the mbuf.\n @return\n   The pointer of the mbuf buffer."]
    pub fn rte_mbuf_buf_addr(
        mb: *mut rte_mbuf,
        mp: *mut rte_mempool,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the default address of the beginning of the mbuf data.\n\n @param mb\n   The pointer to the mbuf.\n @return\n   The pointer of the beginning of the mbuf data."]
    pub fn rte_mbuf_data_addr_default(mb: *mut rte_mbuf) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return address of buffer embedded in the given mbuf.\n\n @note: Accessing mempool pointer of a mbuf is expensive because the\n pointer is stored in the 2nd cache line of mbuf. If mempool is known, it\n is better not to reference the mempool pointer in mbuf but calling\n rte_mbuf_buf_addr() would be more efficient.\n\n @param md\n   The pointer to the mbuf.\n @return\n   The address of the data buffer owned by the mbuf."]
    pub fn rte_mbuf_to_baddr(md: *mut rte_mbuf) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the starting address of the private data area embedded in\n the given mbuf.\n\n Note that no check is made to ensure that a private data area\n actually exists in the supplied mbuf.\n\n @param m\n   The pointer to the mbuf.\n @return\n   The starting address of the private data area of the given mbuf."]
    pub fn rte_mbuf_to_priv(m: *mut rte_mbuf) -> *mut ::std::os::raw::c_void;
}
#[doc = " Private data in case of pktmbuf pool.\n\n A structure that contains some pktmbuf_pool-specific data that are\n appended after the mempool structure (in private data)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pktmbuf_pool_private {
    #[doc = "< Size of data space in each mbuf."]
    pub mbuf_data_room_size: u16,
    #[doc = "< Size of private area in each mbuf."]
    pub mbuf_priv_size: u16,
    #[doc = "< reserved for future use."]
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_rte_pktmbuf_pool_private() {
    const UNINIT: ::std::mem::MaybeUninit<rte_pktmbuf_pool_private> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_pktmbuf_pool_private>(),
        8usize,
        concat!("Size of: ", stringify!(rte_pktmbuf_pool_private))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_pktmbuf_pool_private>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_pktmbuf_pool_private))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mbuf_data_room_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pktmbuf_pool_private),
            "::",
            stringify!(mbuf_data_room_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mbuf_priv_size) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pktmbuf_pool_private),
            "::",
            stringify!(mbuf_priv_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pktmbuf_pool_private),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = " Return the flags from private data in an mempool structure.\n\n @param mp\n   A pointer to the mempool structure.\n @return\n   The flags from the private data structure."]
    pub fn rte_pktmbuf_priv_flags(mp: *mut rte_mempool) -> u32;
}
extern "C" {
    #[doc = " Reads the value of an mbuf's refcnt.\n @param m\n   Mbuf to read\n @return\n   Reference count number."]
    pub fn rte_mbuf_refcnt_read(m: *const rte_mbuf) -> u16;
}
extern "C" {
    #[doc = " Sets an mbuf's refcnt to a defined value.\n @param m\n   Mbuf to update\n @param new_value\n   Value set"]
    pub fn rte_mbuf_refcnt_set(m: *mut rte_mbuf, new_value: u16);
}
extern "C" {
    pub fn __rte_mbuf_refcnt_update(m: *mut rte_mbuf, value: i16) -> u16;
}
extern "C" {
    #[doc = " Adds given value to an mbuf's refcnt and returns its new value.\n @param m\n   Mbuf to update\n @param value\n   Value to add/subtract\n @return\n   Updated value"]
    pub fn rte_mbuf_refcnt_update(m: *mut rte_mbuf, value: i16) -> u16;
}
extern "C" {
    #[doc = " Reads the refcnt of an external buffer.\n\n @param shinfo\n   Shared data of the external buffer.\n @return\n   Reference count number."]
    pub fn rte_mbuf_ext_refcnt_read(shinfo: *const rte_mbuf_ext_shared_info) -> u16;
}
extern "C" {
    #[doc = " Set refcnt of an external buffer.\n\n @param shinfo\n   Shared data of the external buffer.\n @param new_value\n   Value set"]
    pub fn rte_mbuf_ext_refcnt_set(shinfo: *mut rte_mbuf_ext_shared_info, new_value: u16);
}
extern "C" {
    #[doc = " Add given value to refcnt of an external buffer and return its new\n value.\n\n @param shinfo\n   Shared data of the external buffer.\n @param value\n   Value to add/subtract\n @return\n   Updated value"]
    pub fn rte_mbuf_ext_refcnt_update(shinfo: *mut rte_mbuf_ext_shared_info, value: i16) -> u16;
}
extern "C" {
    #[doc = " Sanity checks on an mbuf.\n\n Check the consistency of the given mbuf. The function will cause a\n panic if corruption is detected.\n\n @param m\n   The mbuf to be checked.\n @param is_header\n   True if the mbuf is a packet header, false if it is a sub-segment\n   of a packet (in this case, some fields like nb_segs are not checked)"]
    pub fn rte_mbuf_sanity_check(m: *const rte_mbuf, is_header: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Sanity checks on a mbuf.\n\n Almost like rte_mbuf_sanity_check(), but this function gives the reason\n if corruption is detected rather than panic.\n\n @param m\n   The mbuf to be checked.\n @param is_header\n   True if the mbuf is a packet header, false if it is a sub-segment\n   of a packet (in this case, some fields like nb_segs are not checked)\n @param reason\n   A reference to a string pointer where to store the reason why a mbuf is\n   considered invalid.\n @return\n   - 0 if no issue has been found, reason is left untouched.\n   - -1 if a problem is detected, reason then points to a string describing\n     the reason why the mbuf is deemed invalid."]
    pub fn rte_mbuf_check(
        m: *const rte_mbuf,
        is_header: ::std::os::raw::c_int,
        reason: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sanity checks on a reinitialized mbuf in debug mode.\n\n Check the consistency of the given reinitialized mbuf.\n The function will cause a panic if corruption is detected.\n\n Check that the mbuf is properly reinitialized (refcnt=1, next=NULL,\n nb_segs=1), as done by rte_pktmbuf_prefree_seg().\n\n @param m\n   The mbuf to be checked."]
    pub fn __rte_mbuf_raw_sanity_check(m: *const rte_mbuf);
}
extern "C" {
    #[doc = " Allocate an uninitialized mbuf from mempool *mp*.\n\n This function can be used by PMDs (especially in RX functions) to\n allocate an uninitialized mbuf. The driver is responsible of\n initializing all the required fields. See rte_pktmbuf_reset().\n For standard needs, prefer rte_pktmbuf_alloc().\n\n The caller can expect that the following fields of the mbuf structure\n are initialized: buf_addr, buf_iova, buf_len, refcnt=1, nb_segs=1,\n next=NULL, pool, priv_size. The other fields must be initialized\n by the caller.\n\n @param mp\n   The mempool from which mbuf is allocated.\n @return\n   - The pointer to the new mbuf on success.\n   - NULL if allocation failed."]
    pub fn rte_mbuf_raw_alloc(mp: *mut rte_mempool) -> *mut rte_mbuf;
}
extern "C" {
    #[doc = " Put mbuf back into its original mempool.\n\n The caller must ensure that the mbuf is direct and properly\n reinitialized (refcnt=1, next=NULL, nb_segs=1), as done by\n rte_pktmbuf_prefree_seg().\n\n This function should be used with care, when optimization is\n required. For standard needs, prefer rte_pktmbuf_free() or\n rte_pktmbuf_free_seg().\n\n @param m\n   The mbuf to be freed."]
    pub fn rte_mbuf_raw_free(m: *mut rte_mbuf);
}
extern "C" {
    #[doc = " The packet mbuf constructor.\n\n This function initializes some fields in the mbuf structure that are\n not modified by the user once created (origin pool, buffer start\n address, and so on). This function is given as a callback function to\n rte_mempool_obj_iter() or rte_mempool_create() at pool creation time.\n\n This function expects that the mempool private area was previously\n initialized with rte_pktmbuf_pool_init().\n\n @param mp\n   The mempool from which mbufs originate.\n @param opaque_arg\n   A pointer that can be used by the user to retrieve useful information\n   for mbuf initialization. This pointer is the opaque argument passed to\n   rte_mempool_obj_iter() or rte_mempool_create().\n @param m\n   The mbuf to initialize.\n @param i\n   The index of the mbuf in the pool table."]
    pub fn rte_pktmbuf_init(
        mp: *mut rte_mempool,
        opaque_arg: *mut ::std::os::raw::c_void,
        m: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " A packet mbuf pool constructor.\n\n This function initializes the mempool private data in the case of a\n pktmbuf pool. This private data is needed by the driver. The\n function must be called on the mempool before it is used, or it\n can be given as a callback function to rte_mempool_create() at\n pool creation. It can be extended by the user, for example, to\n provide another packet size.\n\n The mempool private area size must be at least equal to\n sizeof(struct rte_pktmbuf_pool_private).\n\n @param mp\n   The mempool from which mbufs originate.\n @param opaque_arg\n   A pointer that can be used by the user to retrieve useful information\n   for mbuf initialization. This pointer is the opaque argument passed to\n   rte_mempool_create()."]
    pub fn rte_pktmbuf_pool_init(mp: *mut rte_mempool, opaque_arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Create a mbuf pool.\n\n This function creates and initializes a packet mbuf pool. It is\n a wrapper to rte_mempool functions.\n\n @param name\n   The name of the mbuf pool.\n @param n\n   The number of elements in the mbuf pool. The optimum size (in terms\n   of memory usage) for a mempool is when n is a power of two minus one:\n   n = (2^q - 1).\n @param cache_size\n   Size of the per-core object cache. See rte_mempool_create() for\n   details.\n @param priv_size\n   Size of application private are between the rte_mbuf structure\n   and the data buffer. This value must be aligned to RTE_MBUF_PRIV_ALIGN.\n @param data_room_size\n   Size of data buffer in each mbuf, including RTE_PKTMBUF_HEADROOM.\n @param socket_id\n   The socket identifier where the memory should be allocated. The\n   value can be *SOCKET_ID_ANY* if there is no NUMA constraint for the\n   reserved zone.\n @return\n   The pointer to the new allocated mempool, on success. NULL on error\n   with rte_errno set appropriately. Possible rte_errno values include:\n    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure\n    - EINVAL - cache size provided is too large, or priv_size is not aligned.\n    - ENOSPC - the maximum number of memzones has already been allocated\n    - EEXIST - a memzone with the same name already exists\n    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_pktmbuf_pool_create(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        priv_size: u16,
        data_room_size: u16,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut rte_mempool;
}
extern "C" {
    #[doc = " Create a mbuf pool with a given mempool ops name\n\n This function creates and initializes a packet mbuf pool. It is\n a wrapper to rte_mempool functions.\n\n @param name\n   The name of the mbuf pool.\n @param n\n   The number of elements in the mbuf pool. The optimum size (in terms\n   of memory usage) for a mempool is when n is a power of two minus one:\n   n = (2^q - 1).\n @param cache_size\n   Size of the per-core object cache. See rte_mempool_create() for\n   details.\n @param priv_size\n   Size of application private are between the rte_mbuf structure\n   and the data buffer. This value must be aligned to RTE_MBUF_PRIV_ALIGN.\n @param data_room_size\n   Size of data buffer in each mbuf, including RTE_PKTMBUF_HEADROOM.\n @param socket_id\n   The socket identifier where the memory should be allocated. The\n   value can be *SOCKET_ID_ANY* if there is no NUMA constraint for the\n   reserved zone.\n @param ops_name\n   The mempool ops name to be used for this mempool instead of\n   default mempool. The value can be *NULL* to use default mempool.\n @return\n   The pointer to the new allocated mempool, on success. NULL on error\n   with rte_errno set appropriately. Possible rte_errno values include:\n    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure\n    - EINVAL - cache size provided is too large, or priv_size is not aligned.\n    - ENOSPC - the maximum number of memzones has already been allocated\n    - EEXIST - a memzone with the same name already exists\n    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_pktmbuf_pool_create_by_ops(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        priv_size: u16,
        data_room_size: u16,
        socket_id: ::std::os::raw::c_int,
        ops_name: *const ::std::os::raw::c_char,
    ) -> *mut rte_mempool;
}
#[doc = " A structure that describes the pinned external buffer segment."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pktmbuf_extmem {
    #[doc = "< The virtual address of data buffer."]
    pub buf_ptr: *mut ::std::os::raw::c_void,
    #[doc = "< The IO address of the data buffer."]
    pub buf_iova: rte_iova_t,
    #[doc = "< External buffer length in bytes."]
    pub buf_len: usize,
    #[doc = "< mbuf element size in bytes."]
    pub elt_size: u16,
}
#[test]
fn bindgen_test_layout_rte_pktmbuf_extmem() {
    const UNINIT: ::std::mem::MaybeUninit<rte_pktmbuf_extmem> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rte_pktmbuf_extmem>(),
        32usize,
        concat!("Size of: ", stringify!(rte_pktmbuf_extmem))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_pktmbuf_extmem>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_pktmbuf_extmem))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pktmbuf_extmem),
            "::",
            stringify!(buf_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_iova) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pktmbuf_extmem),
            "::",
            stringify!(buf_iova)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pktmbuf_extmem),
            "::",
            stringify!(buf_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elt_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_pktmbuf_extmem),
            "::",
            stringify!(elt_size)
        )
    );
}
extern "C" {
    #[doc = " Create a mbuf pool with external pinned data buffers.\n\n This function creates and initializes a packet mbuf pool that contains\n only mbufs with external buffer. It is a wrapper to rte_mempool functions.\n\n @param name\n   The name of the mbuf pool.\n @param n\n   The number of elements in the mbuf pool. The optimum size (in terms\n   of memory usage) for a mempool is when n is a power of two minus one:\n   n = (2^q - 1).\n @param cache_size\n   Size of the per-core object cache. See rte_mempool_create() for\n   details.\n @param priv_size\n   Size of application private are between the rte_mbuf structure\n   and the data buffer. This value must be aligned to RTE_MBUF_PRIV_ALIGN.\n @param data_room_size\n   Size of data buffer in each mbuf, including RTE_PKTMBUF_HEADROOM.\n @param socket_id\n   The socket identifier where the memory should be allocated. The\n   value can be *SOCKET_ID_ANY* if there is no NUMA constraint for the\n   reserved zone.\n @param ext_mem\n   Pointer to the array of structures describing the external memory\n   for data buffers. It is caller responsibility to register this memory\n   with rte_extmem_register() (if needed), map this memory to appropriate\n   physical device, etc.\n @param ext_num\n   Number of elements in the ext_mem array.\n @return\n   The pointer to the new allocated mempool, on success. NULL on error\n   with rte_errno set appropriately. Possible rte_errno values include:\n    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure\n    - EINVAL - cache size provided is too large, or priv_size is not aligned.\n    - ENOSPC - the maximum number of memzones has already been allocated\n    - EEXIST - a memzone with the same name already exists\n    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_pktmbuf_pool_create_extbuf(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        priv_size: u16,
        data_room_size: u16,
        socket_id: ::std::os::raw::c_int,
        ext_mem: *const rte_pktmbuf_extmem,
        ext_num: ::std::os::raw::c_uint,
    ) -> *mut rte_mempool;
}
extern "C" {
    #[doc = " Get the data room size of mbufs stored in a pktmbuf_pool\n\n The data room size is the amount of data that can be stored in a\n mbuf including the headroom (RTE_PKTMBUF_HEADROOM).\n\n @param mp\n   The packet mbuf pool.\n @return\n   The data room size of mbufs stored in this mempool."]
    pub fn rte_pktmbuf_data_room_size(mp: *mut rte_mempool) -> u16;
}
extern "C" {
    #[doc = " Reset the data_off field of a packet mbuf to its default value.\n\n The given mbuf must have only one segment, which should be empty.\n\n @param m\n   The packet mbuf's data_off field has to be reset."]
    pub fn rte_pktmbuf_reset_headroom(m: *mut rte_mbuf);
}
extern "C" {
    #[doc = " Reset the fields of a packet mbuf to their default values.\n\n The given mbuf must have only one segment.\n\n @param m\n   The packet mbuf to be reset."]
    pub fn rte_pktmbuf_reset(m: *mut rte_mbuf);
}
extern "C" {
    #[doc = " Allocate a new mbuf from a mempool.\n\n This new mbuf contains one segment, which has a length of 0. The pointer\n to data is initialized to have some bytes of headroom in the buffer\n (if buffer size allows).\n\n @param mp\n   The mempool from which the mbuf is allocated.\n @return\n   - The pointer to the new mbuf on success.\n   - NULL if allocation failed."]
    pub fn rte_pktmbuf_alloc(mp: *mut rte_mempool) -> *mut rte_mbuf;
}
extern "C" {
    #[doc = " Allocate a bulk of mbufs, initialize refcnt and reset the fields to default\n values.\n\n  @param pool\n    The mempool from which mbufs are allocated.\n  @param mbufs\n    Array of pointers to mbufs\n  @param count\n    Array size\n  @return\n   - 0: Success\n   - -ENOENT: Not enough entries in the mempool; no mbufs are retrieved."]
    pub fn rte_pktmbuf_alloc_bulk(
        pool: *mut rte_mempool,
        mbufs: *mut *mut rte_mbuf,
        count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize shared data at the end of an external buffer before attaching\n to a mbuf by ``rte_pktmbuf_attach_extbuf()``. This is not a mandatory\n initialization but a helper function to simply spare a few bytes at the\n end of the buffer for shared data. If shared data is allocated\n separately, this should not be called but application has to properly\n initialize the shared data according to its need.\n\n Free callback and its argument is saved and the refcnt is set to 1.\n\n @warning\n The value of buf_len will be reduced to RTE_PTR_DIFF(shinfo, buf_addr)\n after this initialization. This shall be used for\n ``rte_pktmbuf_attach_extbuf()``\n\n @param buf_addr\n   The pointer to the external buffer.\n @param [in,out] buf_len\n   The pointer to length of the external buffer. Input value must be\n   larger than the size of ``struct rte_mbuf_ext_shared_info`` and\n   padding for alignment. If not enough, this function will return NULL.\n   Adjusted buffer length will be returned through this pointer.\n @param free_cb\n   Free callback function to call when the external buffer needs to be\n   freed.\n @param fcb_opaque\n   Argument for the free callback function.\n\n @return\n   A pointer to the initialized shared data on success, return NULL\n   otherwise."]
    pub fn rte_pktmbuf_ext_shinfo_init_helper(
        buf_addr: *mut ::std::os::raw::c_void,
        buf_len: *mut u16,
        free_cb: rte_mbuf_extbuf_free_callback_t,
        fcb_opaque: *mut ::std::os::raw::c_void,
    ) -> *mut rte_mbuf_ext_shared_info;
}
extern "C" {
    #[doc = " Attach an external buffer to a mbuf.\n\n User-managed anonymous buffer can be attached to an mbuf. When attaching\n it, corresponding free callback function and its argument should be\n provided via shinfo. This callback function will be called once all the\n mbufs are detached from the buffer (refcnt becomes zero).\n\n The headroom length of the attaching mbuf will be set to zero and this\n can be properly adjusted after attachment. For example, ``rte_pktmbuf_adj()``\n or ``rte_pktmbuf_reset_headroom()`` might be used.\n\n Similarly, the packet length is initialized to 0. If the buffer contains\n data, the user has to adjust ``data_len`` and the ``pkt_len`` field of\n the mbuf accordingly.\n\n More mbufs can be attached to the same external buffer by\n ``rte_pktmbuf_attach()`` once the external buffer has been attached by\n this API.\n\n Detachment can be done by either ``rte_pktmbuf_detach_extbuf()`` or\n ``rte_pktmbuf_detach()``.\n\n Memory for shared data must be provided and user must initialize all of\n the content properly, especially free callback and refcnt. The pointer\n of shared data will be stored in m->shinfo.\n ``rte_pktmbuf_ext_shinfo_init_helper`` can help to simply spare a few\n bytes at the end of buffer for the shared data, store free callback and\n its argument and set the refcnt to 1. The following is an example:\n\n   struct rte_mbuf_ext_shared_info *shinfo =\n          rte_pktmbuf_ext_shinfo_init_helper(buf_addr, &buf_len,\n                                             free_cb, fcb_arg);\n   rte_pktmbuf_attach_extbuf(m, buf_addr, buf_iova, buf_len, shinfo);\n   rte_pktmbuf_reset_headroom(m);\n   rte_pktmbuf_adj(m, data_len);\n\n Attaching an external buffer is quite similar to mbuf indirection in\n replacing buffer addresses and length of a mbuf, but a few differences:\n - When an indirect mbuf is attached, refcnt of the direct mbuf would be\n   2 as long as the direct mbuf itself isn't freed after the attachment.\n   In such cases, the buffer area of a direct mbuf must be read-only. But\n   external buffer has its own refcnt and it starts from 1. Unless\n   multiple mbufs are attached to a mbuf having an external buffer, the\n   external buffer is writable.\n - There's no need to allocate buffer from a mempool. Any buffer can be\n   attached with appropriate free callback and its IO address.\n - Smaller metadata is required to maintain shared data such as refcnt.\n\n @param m\n   The pointer to the mbuf.\n @param buf_addr\n   The pointer to the external buffer.\n @param buf_iova\n   IO address of the external buffer.\n @param buf_len\n   The size of the external buffer.\n @param shinfo\n   User-provided memory for shared data of the external buffer."]
    pub fn rte_pktmbuf_attach_extbuf(
        m: *mut rte_mbuf,
        buf_addr: *mut ::std::os::raw::c_void,
        buf_iova: rte_iova_t,
        buf_len: u16,
        shinfo: *mut rte_mbuf_ext_shared_info,
    );
}
extern "C" {
    #[doc = " Copy dynamic fields from msrc to mdst.\n\n @param mdst\n   The destination mbuf.\n @param msrc\n   The source mbuf."]
    pub fn rte_mbuf_dynfield_copy(mdst: *mut rte_mbuf, msrc: *const rte_mbuf);
}
extern "C" {
    pub fn __rte_pktmbuf_copy_hdr(mdst: *mut rte_mbuf, msrc: *const rte_mbuf);
}
extern "C" {
    #[doc = " Attach packet mbuf to another packet mbuf.\n\n If the mbuf we are attaching to isn't a direct buffer and is attached to\n an external buffer, the mbuf being attached will be attached to the\n external buffer instead of mbuf indirection.\n\n Otherwise, the mbuf will be indirectly attached. After attachment we\n refer the mbuf we attached as 'indirect', while mbuf we attached to as\n 'direct'.  The direct mbuf's reference counter is incremented.\n\n Right now, not supported:\n  - attachment for already indirect mbuf (e.g. - mi has to be direct).\n  - mbuf we trying to attach (mi) is used by someone else\n    e.g. it's reference counter is greater then 1.\n\n @param mi\n   The indirect packet mbuf.\n @param m\n   The packet mbuf we're attaching to."]
    pub fn rte_pktmbuf_attach(mi: *mut rte_mbuf, m: *mut rte_mbuf);
}
extern "C" {
    #[doc = " @internal used by rte_pktmbuf_detach().\n\n Decrement the reference counter of the external buffer. When the\n reference counter becomes 0, the buffer is freed by pre-registered\n callback."]
    pub fn __rte_pktmbuf_free_extbuf(m: *mut rte_mbuf);
}
extern "C" {
    #[doc = " @internal used by rte_pktmbuf_detach().\n\n Decrement the direct mbuf's reference counter. When the reference\n counter becomes 0, the direct mbuf is freed."]
    pub fn __rte_pktmbuf_free_direct(m: *mut rte_mbuf);
}
extern "C" {
    #[doc = " Detach a packet mbuf from external buffer or direct buffer.\n\n  - decrement refcnt and free the external/direct buffer if refcnt\n    becomes zero.\n  - restore original mbuf address and length values.\n  - reset pktmbuf data and data_len to their default values.\n\n All other fields of the given packet mbuf will be left intact.\n\n If the packet mbuf was allocated from the pool with pinned\n external buffers the rte_pktmbuf_detach does nothing with the\n mbuf of this kind, because the pinned buffers are not supposed\n to be detached.\n\n @param m\n   The indirect attached packet mbuf."]
    pub fn rte_pktmbuf_detach(m: *mut rte_mbuf);
}
extern "C" {
    #[doc = " @internal Handle the packet mbufs with attached pinned external buffer\n on the mbuf freeing:\n\n  - return zero if reference counter in shinfo is one. It means there is\n  no more reference to this pinned buffer and mbuf can be returned to\n  the pool\n\n  - otherwise (if reference counter is not one), decrement reference\n  counter and return non-zero value to prevent freeing the backing mbuf.\n\n Returns non zero if mbuf should not be freed."]
    pub fn __rte_pktmbuf_pinned_extbuf_decref(m: *mut rte_mbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decrease reference counter and unlink a mbuf segment\n\n This function does the same than a free, except that it does not\n return the segment to its pool.\n It decreases the reference counter, and if it reaches 0, it is\n detached from its parent for an indirect mbuf.\n\n @param m\n   The mbuf to be unlinked\n @return\n   - (m) if it is the last reference. It can be recycled or freed.\n   - (NULL) if the mbuf still has remaining references on it."]
    pub fn rte_pktmbuf_prefree_seg(m: *mut rte_mbuf) -> *mut rte_mbuf;
}
extern "C" {
    #[doc = " Free a segment of a packet mbuf into its original mempool.\n\n Free an mbuf, without parsing other segments in case of chained\n buffers.\n\n @param m\n   The packet mbuf segment to be freed."]
    pub fn rte_pktmbuf_free_seg(m: *mut rte_mbuf);
}
extern "C" {
    #[doc = " Free a packet mbuf back into its original mempool.\n\n Free an mbuf, and all its segments in case of chained buffers. Each\n segment is added back into its original mempool.\n\n @param m\n   The packet mbuf to be freed. If NULL, the function does nothing."]
    pub fn rte_pktmbuf_free(m: *mut rte_mbuf);
}
extern "C" {
    #[doc = " Free a bulk of packet mbufs back into their original mempools.\n\n Free a bulk of mbufs, and all their segments in case of chained buffers.\n Each segment is added back into its original mempool.\n\n  @param mbufs\n    Array of pointers to packet mbufs.\n    The array may contain NULL pointers.\n  @param count\n    Array size."]
    pub fn rte_pktmbuf_free_bulk(mbufs: *mut *mut rte_mbuf, count: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Create a \"clone\" of the given packet mbuf.\n\n Walks through all segments of the given packet mbuf, and for each of them:\n  - Creates a new packet mbuf from the given pool.\n  - Attaches newly created mbuf to the segment.\n Then updates pkt_len and nb_segs of the \"clone\" packet mbuf to match values\n from the original packet mbuf.\n\n @param md\n   The packet mbuf to be cloned.\n @param mp\n   The mempool from which the \"clone\" mbufs are allocated.\n @return\n   - The pointer to the new \"clone\" mbuf on success.\n   - NULL if allocation fails."]
    pub fn rte_pktmbuf_clone(md: *mut rte_mbuf, mp: *mut rte_mempool) -> *mut rte_mbuf;
}
extern "C" {
    #[doc = " Create a full copy of a given packet mbuf.\n\n Copies all the data from a given packet mbuf to a newly allocated\n set of mbufs. The private data are is not copied.\n\n @param m\n   The packet mbuf to be copied.\n @param mp\n   The mempool from which the \"clone\" mbufs are allocated.\n @param offset\n   The number of bytes to skip before copying.\n   If the mbuf does not have that many bytes, it is an error\n   and NULL is returned.\n @param length\n   The upper limit on bytes to copy.  Passing UINT32_MAX\n   means all data (after offset).\n @return\n   - The pointer to the new \"clone\" mbuf on success.\n   - NULL if allocation fails."]
    pub fn rte_pktmbuf_copy(
        m: *const rte_mbuf,
        mp: *mut rte_mempool,
        offset: u32,
        length: u32,
    ) -> *mut rte_mbuf;
}
extern "C" {
    #[doc = " Adds given value to the refcnt of all packet mbuf segments.\n\n Walks through all segments of given packet mbuf and for each of them\n invokes rte_mbuf_refcnt_update().\n\n @param m\n   The packet mbuf whose refcnt to be updated.\n @param v\n   The value to add to the mbuf's segments refcnt."]
    pub fn rte_pktmbuf_refcnt_update(m: *mut rte_mbuf, v: i16);
}
extern "C" {
    #[doc = " Get the headroom in a packet mbuf.\n\n @param m\n   The packet mbuf.\n @return\n   The length of the headroom."]
    pub fn rte_pktmbuf_headroom(m: *const rte_mbuf) -> u16;
}
extern "C" {
    #[doc = " Get the tailroom of a packet mbuf.\n\n @param m\n   The packet mbuf.\n @return\n   The length of the tailroom."]
    pub fn rte_pktmbuf_tailroom(m: *const rte_mbuf) -> u16;
}
extern "C" {
    #[doc = " Get the last segment of the packet.\n\n @param m\n   The packet mbuf.\n @return\n   The last segment of the given mbuf."]
    pub fn rte_pktmbuf_lastseg(m: *mut rte_mbuf) -> *mut rte_mbuf;
}
extern "C" {
    #[doc = " Prepend len bytes to an mbuf data area.\n\n Returns a pointer to the new\n data start address. If there is not enough headroom in the first\n segment, the function will return NULL, without modifying the mbuf.\n\n @param m\n   The pkt mbuf.\n @param len\n   The amount of data to prepend (in bytes).\n @return\n   A pointer to the start of the newly prepended data, or\n   NULL if there is not enough headroom space in the first segment"]
    pub fn rte_pktmbuf_prepend(m: *mut rte_mbuf, len: u16) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Append len bytes to an mbuf.\n\n Append len bytes to an mbuf and return a pointer to the start address\n of the added data. If there is not enough tailroom in the last\n segment, the function will return NULL, without modifying the mbuf.\n\n @param m\n   The packet mbuf.\n @param len\n   The amount of data to append (in bytes).\n @return\n   A pointer to the start of the newly appended data, or\n   NULL if there is not enough tailroom space in the last segment"]
    pub fn rte_pktmbuf_append(m: *mut rte_mbuf, len: u16) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Remove len bytes at the beginning of an mbuf.\n\n Returns a pointer to the start address of the new data area. If the\n length is greater than the length of the first segment, then the\n function will fail and return NULL, without modifying the mbuf.\n\n @param m\n   The packet mbuf.\n @param len\n   The amount of data to remove (in bytes).\n @return\n   A pointer to the new start of the data."]
    pub fn rte_pktmbuf_adj(m: *mut rte_mbuf, len: u16) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Remove len bytes of data at the end of the mbuf.\n\n If the length is greater than the length of the last segment, the\n function will fail and return -1 without modifying the mbuf.\n\n @param m\n   The packet mbuf.\n @param len\n   The amount of data to remove (in bytes).\n @return\n   - 0: On success.\n   - -1: On error."]
    pub fn rte_pktmbuf_trim(m: *mut rte_mbuf, len: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Test if mbuf data is contiguous.\n\n @param m\n   The packet mbuf.\n @return\n   - 1, if all data is contiguous (one segment).\n   - 0, if there is several segments."]
    pub fn rte_pktmbuf_is_contiguous(m: *const rte_mbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal used by rte_pktmbuf_read()."]
    pub fn __rte_pktmbuf_read(
        m: *const rte_mbuf,
        off: u32,
        len: u32,
        buf: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Read len data bytes in a mbuf at specified offset.\n\n If the data is contiguous, return the pointer in the mbuf data, else\n copy the data in the buffer provided by the user and return its\n pointer.\n\n @param m\n   The pointer to the mbuf.\n @param off\n   The offset of the data in the mbuf.\n @param len\n   The amount of bytes to read.\n @param buf\n   The buffer where data is copied if it is not contiguous in mbuf\n   data. Its length should be at least equal to the len parameter.\n @return\n   The pointer to the data, either in the mbuf if it is contiguous,\n   or in the user buffer. If mbuf is too small, NULL is returned."]
    pub fn rte_pktmbuf_read(
        m: *const rte_mbuf,
        off: u32,
        len: u32,
        buf: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Chain an mbuf to another, thereby creating a segmented packet.\n\n Note: The implementation will do a linear walk over the segments to find\n the tail entry. For cases when there are many segments, it's better to\n chain the entries manually.\n\n @param head\n   The head of the mbuf chain (the first packet)\n @param tail\n   The mbuf to put last in the chain\n\n @return\n   - 0, on success.\n   - -EOVERFLOW, if the chain segment limit exceeded"]
    pub fn rte_pktmbuf_chain(head: *mut rte_mbuf, tail: *mut rte_mbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " For given input values generate raw tx_offload value.\n Note that it is caller responsibility to make sure that input parameters\n don't exceed maximum bit-field values.\n @param il2\n   l2_len value.\n @param il3\n   l3_len value.\n @param il4\n   l4_len value.\n @param tso\n   tso_segsz value.\n @param ol3\n   outer_l3_len value.\n @param ol2\n   outer_l2_len value.\n @param unused\n   unused value.\n @return\n   raw tx_offload value."]
    pub fn rte_mbuf_tx_offload(
        il2: u64,
        il3: u64,
        il4: u64,
        tso: u64,
        ol3: u64,
        ol2: u64,
        unused: u64,
    ) -> u64;
}
extern "C" {
    #[doc = " Validate general requirements for Tx offload in mbuf.\n\n This function checks correctness and completeness of Tx offload settings.\n\n @param m\n   The packet mbuf to be validated.\n @return\n   0 if packet is valid"]
    pub fn rte_validate_tx_offload(m: *const rte_mbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal used by rte_pktmbuf_linearize()."]
    pub fn __rte_pktmbuf_linearize(mbuf: *mut rte_mbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Linearize data in mbuf.\n\n This function moves the mbuf data in the first segment if there is enough\n tailroom. The subsequent segments are unchained and freed.\n\n @param mbuf\n   mbuf to linearize\n @return\n   - 0, on success\n   - -1, on error"]
    pub fn rte_pktmbuf_linearize(mbuf: *mut rte_mbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump an mbuf structure to a file.\n\n Dump all fields for the given packet mbuf and all its associated\n segments (in the case of a chained buffer).\n\n @param f\n   A pointer to a file for output\n @param m\n   The packet mbuf.\n @param dump_len\n   If dump_len != 0, also dump the \"dump_len\" first data bytes of\n   the packet."]
    pub fn rte_pktmbuf_dump(f: *mut FILE, m: *const rte_mbuf, dump_len: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Get the value of mbuf sched queue_id field."]
    pub fn rte_mbuf_sched_queue_get(m: *const rte_mbuf) -> u32;
}
extern "C" {
    #[doc = " Get the value of mbuf sched traffic_class field."]
    pub fn rte_mbuf_sched_traffic_class_get(m: *const rte_mbuf) -> u8;
}
extern "C" {
    #[doc = " Get the value of mbuf sched color field."]
    pub fn rte_mbuf_sched_color_get(m: *const rte_mbuf) -> u8;
}
extern "C" {
    #[doc = " Get the values of mbuf sched queue_id, traffic_class and color.\n\n @param m\n   Mbuf to read\n @param queue_id\n  Returns the queue id\n @param traffic_class\n  Returns the traffic class id\n @param color\n  Returns the colour id"]
    pub fn rte_mbuf_sched_get(
        m: *const rte_mbuf,
        queue_id: *mut u32,
        traffic_class: *mut u8,
        color: *mut u8,
    );
}
extern "C" {
    #[doc = " Set the mbuf sched queue_id to the defined value."]
    pub fn rte_mbuf_sched_queue_set(m: *mut rte_mbuf, queue_id: u32);
}
extern "C" {
    #[doc = " Set the mbuf sched traffic_class id to the defined value."]
    pub fn rte_mbuf_sched_traffic_class_set(m: *mut rte_mbuf, traffic_class: u8);
}
extern "C" {
    #[doc = " Set the mbuf sched color id to the defined value."]
    pub fn rte_mbuf_sched_color_set(m: *mut rte_mbuf, color: u8);
}
extern "C" {
    #[doc = " Set the mbuf sched queue_id, traffic_class and color.\n\n @param m\n   Mbuf to set\n @param queue_id\n  Queue id value to be set\n @param traffic_class\n  Traffic class id value to be set\n @param color\n  Color id to be set"]
    pub fn rte_mbuf_sched_set(m: *mut rte_mbuf, queue_id: u32, traffic_class: u8, color: u8);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
